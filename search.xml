<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024 moectf</title>
    <url>/2024/10/22/bb6cbb89/</url>
    <content><![CDATA[<h1 id="Signin"><a href="#Signin" class="headerlink" title="Signin"></a>Signin</h1><pre><code class="python">from Crypto.Util.number import *
from sympy import symbols, solve
import gmpy2

c = 5654386228732582062836480859915557858019553457231956237167652323191768422394980061906028416785155458721240012614551996577092521454960121688179565370052222983096211611352630963027300416387011219744891121506834201808533675072141450111382372702075488292867077512403293072053681315714857246273046785264966933854754543533442866929316042885151966997466549713023923528666038905359773392516627983694351534177829247262148749867874156066768643169675380054673701641774814655290118723774060082161615682005335103074445205806731112430609256580951996554318845128022415956933291151825345962528562570998777860222407032989708801549746
pq = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687154230787854196153067547938936776488741864214499155892870610823979739278296501074632962069426593691194105670021035337609896886690049677222778251559566664735419100459953672218523709852732976706321086266274840999100037702428847290063111455101343033924136386513077951516363739936487970952511422443500922412450462
qp = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687077087914198877794354459669808240133383828356379423767736753506794441545506312066344576298453957064590180141648690226266236642320508613544047037110363523129966437840660693885863331837516125853621802358973786440314619135781324447765480391038912783714312479080029167695447650048419230865326299964671353746764860
n = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687534959910892789661065614807265825078942931717855566686073463382398417205648946713373617006449901977718981043020664616841303517708207413215548110294271101267236070252015782044263961319221848136717220979435486850254298686692230935985442120369913666939804135884857831857184001072678312992442792825575636200505903
p_q = 279533706577501791569740668595544511920056954944184570513187478007551195831693428589898548339751066551225424790534556602157835468618845221423643972870671556362200734472399328046960316064864571163851111207448753697980178391430044714097464866523838747053135392202848167518870720149808055682621080992998747265496
e = 65537

x = symbols(&#39;x&#39;)
equation = x**2 - p_q*x + n
solutions = solve(equation, x)
p = int(solutions[0])
q = int(solutions[1])
phi = (p - 1) * (q - 1)
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
</code></pre>
<h1 id="rsa-revenge"><a href="#rsa-revenge" class="headerlink" title="rsa_revenge"></a>rsa_revenge</h1><pre><code class="python">from Crypto.Util.number import getPrime, isPrime, bytes_to_long
from secret import flag


def emirp(x):
  y = 0
  while x !=0:
    y = y*2 + x%2
    x = x//2
  return y


while True:
  p = getPrime(512)
  q = emirp(p)
  if isPrime(q):
    break

n = p*q
e = 65537
m = bytes_to_long(flag)
c = pow(m,e,n)
print(f&quot;&#123;n = &#125;&quot;)
print(f&quot;&#123;c = &#125;&quot;)

&quot;&quot;&quot;
n = 141326884939079067429645084585831428717383389026212274986490638181168709713585245213459139281395768330637635670530286514361666351728405851224861268366256203851725349214834643460959210675733248662738509224865058748116797242931605149244469367508052164539306170883496415576116236739853057847265650027628600443901
c = 47886145637416465474967586561554275347396273686722042112754589742652411190694422563845157055397690806283389102421131949492150512820301748529122456307491407924640312270962219946993529007414812671985960186335307490596107298906467618684990500775058344576523751336171093010950665199612378376864378029545530793597
&quot;&quot;&quot;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

e = 65537
n = 141326884939079067429645084585831428717383389026212274986490638181168709713585245213459139281395768330637635670530286514361666351728405851224861268366256203851725349214834643460959210675733248662738509224865058748116797242931605149244469367508052164539306170883496415576116236739853057847265650027628600443901
c = 47886145637416465474967586561554275347396273686722042112754589742652411190694422563845157055397690806283389102421131949492150512820301748529122456307491407924640312270962219946993529007414812671985960186335307490596107298906467618684990500775058344576523751336171093010950665199612378376864378029545530793597
def t(a, b, k):
    # sqrt(n)有512位2进制位, 需计算高低位每边的256位
  if k == 256:
    if a*b == n:
      print(a, b)
    return
  for i in range(2):
    for j in range(2):
            # 对两个素数因子尝试爆破未遍历的位爆破
      a1 = a + i*(2**k) + j*(2**(511-k))
      b1 = b + j*(2**k) + i*(2**(511-k))
      if a1*b1 &gt; n:
                # 当a1和b1过大
        continue
      if (a1+(2**(511-k)))*(b1+(2**(511-k))) &lt; n:
                # 当a1和b1过小
        continue
      if ((a1*b1)%(2**(k+1))) != (n%(2**(k+1))):
                # 当a1*b1的最后k+1位（不变）与n的最后k+1位不同
        continue
            # 满足条件的(a1,b1)值，尝试继续遍历
      t(a1, b1, k+1)

# 两个素数因子有512位2进制位, 尝试可能的所有中间位
for i in range(2):
  t(i*(2**256), i*(2**256), 0)

p = 12119998731259483292178496920109290754181396164390285597126378297678818779092115139911720576157973310671490865211601201831597946479039132512609504866583931
q = 11660635291534613230423193509391946961264539191735481147071890944740311229658362673314192872117237108949853531941630122241060679012089130178372253390640871
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
</code></pre>
<h1 id="DA-BAI-TU"><a href="#DA-BAI-TU" class="headerlink" title="DA_BAI_TU"></a>DA_BAI_TU</h1><pre><code class="python">from Crypto.Util.number import *

flag = b&#39;moectf&#123;xxxxxxxxxx&#125;&#39;
m = bytes_to_long(flag)

e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137
e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697

def encrypt(m , e1 , e2):
  p = getPrime(512)
  q = getPrime(512)
  N = p*q
  c1 = pow((3*p + 7*q),e1,N)
  c2 = pow((2*p + 5*q),e2,N)
  e = 65537
  c = pow(m , e , N)
  return c
  

print(encrypt(m ,e1 , e2))

&#39;&#39;&#39;
N = 107840121617107284699019090755767399009554361670188656102287857367092313896799727185137951450003247965287300048132826912467422962758914809476564079425779097585271563973653308788065070590668934509937791637166407147571226702362485442679293305752947015356987589781998813882776841558543311396327103000285832158267
c1 = 15278844009298149463236710060119404122281203585460351155794211733716186259289419248721909282013233358914974167205731639272302971369075321450669419689268407608888816060862821686659088366316321953682936422067632021137937376646898475874811704685412676289281874194427175778134400538795937306359483779509843470045
c2 = 21094604591001258468822028459854756976693597859353651781642590543104398882448014423389799438692388258400734914492082531343013931478752601777032815369293749155925484130072691903725072096643826915317436719353858305966176758359761523170683475946913692317028587403027415142211886317152812178943344234591487108474
c = 21770231043448943684137443679409353766384859347908158264676803189707943062309013723698099073818477179441395009450511276043831958306355425252049047563947202180509717848175083113955255931885159933086221453965914552773593606054520151827862155643433544585058451821992566091775233163599161774796561236063625305050
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

N = 107840121617107284699019090755767399009554361670188656102287857367092313896799727185137951450003247965287300048132826912467422962758914809476564079425779097585271563973653308788065070590668934509937791637166407147571226702362485442679293305752947015356987589781998813882776841558543311396327103000285832158267
c1 = 15278844009298149463236710060119404122281203585460351155794211733716186259289419248721909282013233358914974167205731639272302971369075321450669419689268407608888816060862821686659088366316321953682936422067632021137937376646898475874811704685412676289281874194427175778134400538795937306359483779509843470045
c2 = 21094604591001258468822028459854756976693597859353651781642590543104398882448014423389799438692388258400734914492082531343013931478752601777032815369293749155925484130072691903725072096643826915317436719353858305966176758359761523170683475946913692317028587403027415142211886317152812178943344234591487108474
c = 21770231043448943684137443679409353766384859347908158264676803189707943062309013723698099073818477179441395009450511276043831958306355425252049047563947202180509717848175083113955255931885159933086221453965914552773593606054520151827862155643433544585058451821992566091775233163599161774796561236063625305050
e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137
e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697
e = 65537

kq = pow(2, e1 * e2, N)*pow(c1, e2, N) - pow(3,e1 * e2, N)*pow(c2, e1, N)
q = gmpy2.gcd(kq, N)
p = N // q
phi = (p-1)*(q-1)
d = gmpy2.invert(e, phi)
m = pow(c, d, N)
print(long_to_bytes(m))
</code></pre>
<h1 id="ez-hash"><a href="#ez-hash" class="headerlink" title="ez_hash"></a>ez_hash</h1><pre><code class="python">from hashlib import sha256
from secret import flag, secrets

assert flag == b&#39;moectf&#123;&#39; + secrets + b&#39;&#125;&#39;
assert secrets[:4] == b&#39;2100&#39; and len(secrets) == 10
hash_value = sha256(secrets).hexdigest()
print(f&quot;&#123;hash_value = &#125;&quot;)
hash_value = &#39;3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from hashlib import sha256
from Crypto.Util.number import *

hash_value = &#39;3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a&#39;

for i in range(256**7):
  secrets = b&#39;2100&#39; + str(i).encode()
  if sha256(secrets).hexdigest() == hash_value:
    print(f&quot;&#123;secrets = &#125;&quot;)
    break
  
secrets = b&#39;2100360168&#39;
flag = b&#39;moectf&#123;&#39; + secrets + b&#39;&#125;&#39;
print(flag)
</code></pre>
<h1 id="new-system"><a href="#new-system" class="headerlink" title="new_system"></a>new_system</h1><pre><code class="python">from random import randint
from Crypto.Util.number import getPrime,bytes_to_long 


flag = b&#39;moectf&#123;???????????????&#125;&#39;
gift = bytes_to_long(flag)


def parametergenerate():
  q = getPrime(256)
  gift1 = randint(1, q)
  gift2 = (gift - gift1) % q
  x = randint(1, q)
  assert gift == (gift1 + gift2) % q
  return q , x , gift1, gift2


def encrypt(m , q , x):
  a = randint(1, q)
  c = (a*x + m) % q
  return [a , c]


q , x , gift1 , gift2 = parametergenerate()
print(encrypt(gift1 , q , x))
print(encrypt(gift2 , q , x))
print(encrypt(gift , q , x))
print(f&#39;q = &#123;q&#125;&#39;)

&#39;&#39;&#39;
[48152794364522745851371693618734308982941622286593286738834529420565211572487, 21052760152946883017126800753094180159601684210961525956716021776156447417961]
[48649737427609115586886970515713274413023152700099032993736004585718157300141, 6060718815088072976566240336428486321776540407635735983986746493811330309844]
[30099883325957937700435284907440664781247503171217717818782838808179889651361, 85333708281128255260940125642017184300901184334842582132090488518099650581761]
q = 105482865285555225519947662900872028851795846950902311343782163147659668129411
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2


ac1 = [48152794364522745851371693618734308982941622286593286738834529420565211572487, 21052760152946883017126800753094180159601684210961525956716021776156447417961]
ac2 = [48649737427609115586886970515713274413023152700099032993736004585718157300141, 6060718815088072976566240336428486321776540407635735983986746493811330309844]
ac3 = [30099883325957937700435284907440664781247503171217717818782838808179889651361, 85333708281128255260940125642017184300901184334842582132090488518099650581761]
q = 105482865285555225519947662900872028851795846950902311343782163147659668129411

x = (ac1[1] + ac2[1] - ac3[1]) * gmpy2.invert(ac1[0] + ac2[0] - ac3[0], q) % q
gift = (ac3[1] - x * ac3[0]) % q
print(long_to_bytes(gift))
</code></pre>
<h1 id="small-and-big"><a href="#small-and-big" class="headerlink" title="small_and_big"></a>small_and_big</h1><pre><code class="python">from secret import flag
from Crypto.Util.number import*
m = bytes_to_long(flag)
p = getPrime(1024)
q = getPrime(1024)
n = p*q
e = 3
c = pow(m,e,n)
&#39;&#39;&#39;
c = 150409620528288093947185249913242033500530715593845912018225648212915478065982806112747164334970339684262757
e = 3
n = 20279309983698966932589436610174513524888616098014944133902125993694471293062261713076591251054086174169670848598415548609375570643330808663804049384020949389856831520202461767497906977295453545771698220639545101966866003886108320987081153619862170206953817850993602202650467676163476075276351519648193219850062278314841385459627485588891326899019745457679891867632849975694274064320723175687748633644074614068978098629566677125696150343248924059801632081514235975357906763251498042129457546586971828204136347260818828746304688911632041538714834683709493303900837361850396599138626509382069186433843547745480160634787
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import*
import gmpy2

c = 150409620528288093947185249913242033500530715593845912018225648212915478065982806112747164334970339684262757
e = 3
n = 20279309983698966932589436610174513524888616098014944133902125993694471293062261713076591251054086174169670848598415548609375570643330808663804049384020949389856831520202461767497906977295453545771698220639545101966866003886108320987081153619862170206953817850993602202650467676163476075276351519648193219850062278314841385459627485588891326899019745457679891867632849975694274064320723175687748633644074614068978098629566677125696150343248924059801632081514235975357906763251498042129457546586971828204136347260818828746304688911632041538714834683709493303900837361850396599138626509382069186433843547745480160634787

k = 0
while(1):
  m = k * n + c
  a, b = gmpy2.iroot(m, e)
  if b:
    print(long_to_bytes(a))
    break
  k += 1
</code></pre>
<h1 id="baby-equation"><a href="#baby-equation" class="headerlink" title="baby_equation"></a>baby_equation</h1><pre><code class="python">from Crypto.Util.number import *
from secret import flag

l = len(flag)
m1, m2 = flag[:l//2], flag[l//2:]
a = bytes_to_long(m1)
b = bytes_to_long(m2)
k = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40
assert ((a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1)) == 4*(k + a*b)
</code></pre>
<p>exp:</p>
<pre><code class="python">import gmpy2
from Crypto.Util.number import long_to_bytes


def find(tot, index, ls):
    &quot;&quot;&quot;
    递归查找函数，用于寻找合适的因子组合，使得通过这些因子构造出的数字能够还原出 flag。
    :param tot: 当前的乘积值（初始值为1）。
    :param index: 当前处理的因子索引。
    :param ls: 因子列表，包含所有可能的因子。
    :return: 满足条件的乘积值，如果未找到则返回0。
    &quot;&quot;&quot;
    # 基准情况：如果已经检查了所有因子
    if index == len(ls):
        # 检查当前的 tot 是否可能包含 flag 的特征字符串（例如 &#39;moectf&#123;&#39;）
        if b&#39;moectf&#123;&#39; in long_to_bytes(tot):
            return tot  # 返回找到的值
        return 0  # 没找到返回 0

    # 递归查找，尝试包含当前因子的情况
    a = find(tot * ls[index], index + 1, ls)
    # 递归查找，尝试不包含当前因子的情况
    b = find(tot, index + 1, ls)

    # 返回找到的非零结果
    return a if a != 0 else b


# 给定的常量 k 值
k = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40

# 计算 a1b1 = sqrt(4 * k)
a1b1 = gmpy2.iroot(4 * k, 2)[0]

# 因子列表，包含可能分解出的因子组合
fac = [
    2, 2, 2, 2, 3, 3, 31, 61, 223, 4013, 281317, 4151351, 339386329, 370523737,
    5404604441993, 26798471753993, 25866088332911027256931479223,
    64889106213996537255229963986303510188999911
]

# 使用递归查找因子组合，得到 a1
a1 = find(1, 0, fac)

# 计算 b1 = a1b1 // a1
b1 = a1b1 // a1

# 使用 long_to_bytes 将 a1 和 b1 转换为字节并输出 flag
print(long_to_bytes(a1 - 1) + long_to_bytes(b1 + 1))
</code></pre>
]]></content>
      <categories>
        <category>比赛小屋</category>
      </categories>
  </entry>
  <entry>
    <title>2024 SHCTF</title>
    <url>/2024/10/22/2f72a073/</url>
    <content><![CDATA[<h1 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h1><h2 id="EzAES"><a href="#EzAES" class="headerlink" title="EzAES"></a>EzAES</h2><pre><code class="python">from Crypto.Cipher import AES
import os

iv = os.urandom(16)
key = os.urandom(16)
my_aes = AES.new(key, AES.MODE_CBC, iv)
flag = open(&#39;flag.txt&#39;, &#39;rb&#39;).read()
flag += (16 - len(flag) % 16) * b&#39; &#39;
c = my_aes.encrypt(flag)
print(c)
print(iv)
print(key)
&#39;&#39;&#39;
b&#39;\xe6\x1fD\x8bn*\xb2!5DaE\xee\x83\x86_\x86\x08\xdb\xea\xf3q99\xfa\x08]\x17n\x96.\xf0\xcb9\x15\xa8\xf0\x12\xe85p\xa8\xfc\x1e\x12\xbfl\x0c&#39;
b&#39;\xf8\x1f\xb2\xa2\xdb\x84\xc8\xb8\x9bh\xa4Uh|\xed\xae&#39;
b&#39;\x13\xde\xf6Y\xe7H\x89H|\xce\x1fTkz\xe6\n&#39;
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Cipher import AES

ciphertext = b&#39;\xe6\x1fD\x8bn*\xb2!5DaE\xee\x83\x86_\x86\x08\xdb\xea\xf3q99\xfa\x08]\x17n\x96.\xf0\xcb9\x15\xa8\xf0\x12\xe85p\xa8\xfc\x1e\x12\xbfl\x0c&#39;
iv = b&#39;\xf8\x1f\xb2\xa2\xdb\x84\xc8\xb8\x9bh\xa4Uh|\xed\xae&#39;
key = b&#39;\x13\xde\xf6Y\xe7H\x89H|\xce\x1fTkz\xe6\n&#39;

aes = AES.new(key, AES.MODE_CBC, iv)
decrypted_flag = aes.decrypt(ciphertext)
decrypted_flag = decrypted_flag.rstrip(b&#39; &#39;)

print(decrypted_flag.decode())
</code></pre>
<h2 id="Hello-Crypto"><a href="#Hello-Crypto" class="headerlink" title="Hello Crypto"></a>Hello Crypto</h2><pre><code class="python">m = 215055650564999509155326058585660295319513294943685548748323206379977260136134233952601043141828377900172372474598051314301
print(long_to_bytes(m))
</code></pre>
<h2 id="baby-mod"><a href="#baby-mod" class="headerlink" title="baby_mod"></a>baby_mod</h2><pre><code class="python">from Crypto.Util.number import *
from enc import flag

m = bytes_to_long(flag)
p = getPrime(512)
q = getPrime(512)
r = getPrime(777)
t = getPrime(777)
tmp = getPrime(15)
e = 65537
n = p*q
print(f&quot;c = &#123;pow(m,e,n)&#125;&quot;)
print(f&quot;leak = &#123;p*r-q*t-tmp&#125;&quot;)
print(f&quot;r = &#123;r&#125;&quot;)
print(f&quot;t = &#123;t&#125;&quot;)
&#39;&#39;&#39;
c = 61211771638158371087808400372918576738939016114990617234184110097298299419154496357343926914405803526196970530921576382828387503007331401017198350535164213495715440525133378099636783880540843497044492711316786652114251942258505914694075893281219672129646672393261293645049489777097400432566313708247399622553
leak = -1252849504732846691436274926240147548139531100983805052435309927194848742222153277186099477028462582629799465992084760143354445381099735801300065566762557123147846460105037981222278579628553259685633888197421663719015114218778689216903214380960113075271124329685535690780139961213564358588885756205002999772883325078761443924453722635981864064361638746711520896205568785840606997401884139
r = 536741313487865680021850054550575718160071762359365703121122133538676775165614196816470242976654893518050377281172378029389910347012355575822887151594996160422316967245952449856330498078814859567536192742194556882943652058284677316663
t = 715587548116016583182373119840004916400694943609746480855437504057056067467359267834474943781297633252545077271085397197104023684431804124367370885385718787258143315642069791507889894766685591493426037264574231236323589784717650593003
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

c = 61211771638158371087808400372918576738939016114990617234184110097298299419154496357343926914405803526196970530921576382828387503007331401017198350535164213495715440525133378099636783880540843497044492711316786652114251942258505914694075893281219672129646672393261293645049489777097400432566313708247399622553
leak = -1252849504732846691436274926240147548139531100983805052435309927194848742222153277186099477028462582629799465992084760143354445381099735801300065566762557123147846460105037981222278579628553259685633888197421663719015114218778689216903214380960113075271124329685535690780139961213564358588885756205002999772883325078761443924453722635981864064361638746711520896205568785840606997401884139
r = 536741313487865680021850054550575718160071762359365703121122133538676775165614196816470242976654893518050377281172378029389910347012355575822887151594996160422316967245952449856330498078814859567536192742194556882943652058284677316663
t = 715587548116016583182373119840004916400694943609746480855437504057056067467359267834474943781297633252545077271085397197104023684431804124367370885385718787258143315642069791507889894766685591493426037264574231236323589784717650593003
e = 65537

tmp = 1&lt;&lt;12
while tmp&lt;(1&lt;&lt;15):
    tmp = gmpy2.next_prime(tmp)
    p = (leak+tmp)%t * gmpy2.invert(r,t)%t
    if isPrime(p):
        d = gmpy2.invert(e,p-1)
        print(long_to_bytes(pow(c,d,p)))
 
#(leak_tmp)%r = -qt%r = -q + t%r  
#SHCTF&#123;992cd020-c077-4322-b725-42abb07351c8&#125;
</code></pre>
<h2 id="d-known"><a href="#d-known" class="headerlink" title="d_known"></a>d_known</h2><pre><code class="python">from Crypto.Util.number import *
from gmpy2 import*
from flag import flag

m = bytes_to_long(flag)
p = getPrime(1024)
q = next_prime(p)
n = p * q
e = 0x10001
d = inverse(e, (p-1) * (q-1))
c = pow(m, e, n)
print(c)
print(d)

&#39;&#39;&#39;
c = 4600230281267670190398691735540287332835029091649559162242994978060955322828010435731136178500465942054812311232624925489266243836092176501791621127782184537767161909907416813615253739010690520590986413319986775468559116670278196282034112172658877486112219076392555621281074647641440128758471132003490453972896684466780331920970202661656629733866661340879988071638470586209790421838567131974190000906381034342845259079134283494397567384976584862013092376473009692460708922537454131054606615864569082664299799733297934161568618242736513760486480396700350252805192779870047955771000392233372656197050480109393862239035
d = 1637399515703211078397367150183478186660293773954718953877315813051552836707867873798116237441650111482157214602021048679216717916201356350202988580017364819110062586396238837612080674485212200365636490187400223340528641847035869050414280344510481226645955663214349193813227527693154828870146312003753751686169722675486775232603248961369988600106180197208602445313595652812166427339426694174681115077765663663654241025593890251212572938818736503373294960126743060991203594966295858520465592922805973908341744918382431029027899653690095400830917742533201101270475933382707928321772881673270715605569460793612419884801
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

c = 4600230281267670190398691735540287332835029091649559162242994978060955322828010435731136178500465942054812311232624925489266243836092176501791621127782184537767161909907416813615253739010690520590986413319986775468559116670278196282034112172658877486112219076392555621281074647641440128758471132003490453972896684466780331920970202661656629733866661340879988071638470586209790421838567131974190000906381034342845259079134283494397567384976584862013092376473009692460708922537454131054606615864569082664299799733297934161568618242736513760486480396700350252805192779870047955771000392233372656197050480109393862239035
d = 1637399515703211078397367150183478186660293773954718953877315813051552836707867873798116237441650111482157214602021048679216717916201356350202988580017364819110062586396238837612080674485212200365636490187400223340528641847035869050414280344510481226645955663214349193813227527693154828870146312003753751686169722675486775232603248961369988600106180197208602445313595652812166427339426694174681115077765663663654241025593890251212572938818736503373294960126743060991203594966295858520465592922805973908341744918382431029027899653690095400830917742533201101270475933382707928321772881673270715605569460793612419884801
e = 0x10001

ed1 = e*d - 1
for k in range(1, e):
    if ed1%k == 0:
        phi = ed1//k 
        p = gmpy2.iroot(phi,2)[0]
        p = gmpy2.next_prime(p)
        q = phi//(p-1)+1
        if phi%(p-1) == 0 and isPrime(q):
            n = p*q 
            m = pow(c,d,p*q)
            print(long_to_bytes(m))
</code></pre>
<h2 id="factor"><a href="#factor" class="headerlink" title="factor"></a>factor</h2><pre><code class="python">from Crypto.Util.number import *
import random
from enc import flag

m = bytes_to_long(flag)
e = 65537
def prod(iterable):
    result = 1
    for num in iterable:
        result *= num
    return result
prime_list = [getPrime(64) for _ in  range(10) ]
N = prod(prime_list)
p_list = random.sample(prime_list,7)
n = prod(p_list)
c = pow(m,e,n)
print(f&quot;c = &#123;c&#125;&quot;)
print(f&quot;N = &#123;N&#125;&quot;)
&#39;&#39;&#39;
c = 73488169667020343318223059126014050465055844906415659708825933450494977910190223838429937933790517351045497142177773714983767121855464
N = 431232874576301127435127434279825533139630015759842615056687579694019220839209951903564919902341404408199034325446387060799438649314010381072226821967363534469677017755666763642624118218930109
&#39;&#39;&#39;
</code></pre>
<p>先yafu分解，然后再逐个穷举</p>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *

c = 73488169667020343318223059126014050465055844906415659708825933450494977910190223838429937933790517351045497142177773714983767121855464
N = 431232874576301127435127434279825533139630015759842615056687579694019220839209951903564919902341404408199034325446387060799438649314010381072226821967363534469677017755666763642624118218930109
e = 65537

p = 9292812348409556171
q = 16318832756704646269

prime_list = [9292812348409556171,16318832756704646269,17985845699822927027,13846300579242252271,15496860097451023303,15238533262838411711,13697383528283934943,18191077546028667869,13237487137576261919,14659613209196126947]
phi1 = 1
for i in prime_list:
    phi1 *= i - 1

for i in prime_list:
    for j in prime_list:
        for k in prime_list:
            phi = phi1 // (i - 1) // (j - 1) // (k - 1)
            d = inverse(e, phi)
            n = N // (i * j * k)
            m = pow(c, d, n)
            if b&#39;SHCTF&#123;&#39; in long_to_bytes(m):
                print(long_to_bytes(m))
</code></pre>
<h1 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h1><h2 id="E-R"><a href="#E-R" class="headerlink" title="E&amp;R"></a>E&amp;R</h2><pre><code class="python">#sage
from Crypto.Util.number import *
from secret import flag

flag = flag[6:-1]
l = len(flag)
m1 = bytes_to_long(flag[:l//2])
m2 = bytes_to_long(flag[l//2:])
#RSA
p = getPrime(256)
q = getPrime(256)
n = p * q
e = 65537
r_q = int(bin(q)[2:][::-1] , 2)
leak = p ^^ r_q
c = pow(m2,e,n)

#ECC
E = EllipticCurve(Zmod(n),[114514,1919810])
G = E.lift_x(Integer(m1))
P = G * e
print(f&#39;leak = &#123;leak&#125;&#39;)
print(f&#39;n = &#123;n&#125;&#39;)
print(f&#39;c = &#123;c&#125;&#39;)
print(f&#39;P = &#123;P&#125;&#39;)
# leak = 5599968251197363876087002284371721787318931284225671549507477934076746561842
# n = 7120275986401660066259983193598830554385933355254283093021239164350142898387660104515624591378875067038235085428170557400012848874756868985306042421950909
# c = 6803450117490196163076010186755045681029929816618361161925865477601994608941714788803007124967390157378525581080320415602012078322064392991884070073083436
# P = (4143131125485719352848137000299706175276016714942734255688381872061184989156686585992844083387698688432978380177564346382756951426943827434190895490233627 : 3879946878859691332371384275396678851932267609535096278038417524609690721322205780110680003522999409696718745532857001461869452116434787256032366267905519 : 1)
</code></pre>
<p>exp:</p>
<p>爆破p</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

leak = 5599968251197363876087002284371721787318931284225671549507477934076746561842
n = 7120275986401660066259983193598830554385933355254283093021239164350142898387660104515624591378875067038235085428170557400012848874756868985306042421950909
c = 6803450117490196163076010186755045681029929816618361161925865477601994608941714788803007124967390157378525581080320415602012078322064392991884070073083436
P = (4143131125485719352848137000299706175276016714942734255688381872061184989156686585992844083387698688432978380177564346382756951426943827434190895490233627,3879946878859691332371384275396678851932267609535096278038417524609690721322205780110680003522999409696718745532857001461869452116434787256032366267905519)
e = 65537

# flag2
def pq_xor(tp,tq,idx):
    global ok,cnt 
    if ok:
        return 
 
    #通过tq的尾部得到tp的尾部
    mod =2^idx 
    p = int(tp,2)
    ql = int(tq[::-1],2)%mod
    pl = N*gmpy2.invert(ql,mod)%mod
    p += pl
    #通过p的尾部得到q的头部
    qh = (pl^^leak)%mod
    # print(hex(qh),hex(pl), hex(mod),hex(pl^^leak))
    q = int((bin(qh)[2:].zfill(256))[::-1],2)+ql
    mid = int(&#39;1&#39;*(256-2*idx) + &#39;0&#39;*idx,2)
    print(hex(mid))
    print(hex(p))
    print(hex(q))
    #过滤掉越界的部分
    if p*q&gt;N:
        return False 
    elif (p+mid)*(q+mid)&lt;N:
        return False    
    
    if idx&gt;=80:
        cnt += 1
        try:
            PR.&lt;x&gt; = PolynomialRing(Zmod(N))
            f = int(tp,2) + x*mod + pl 
            print(&#39;Try&#39;, len(hex(p)))
            rr = f.monic().small_roots(X=2^(256-2*idx), beta=0.4)
            if rr != []:
                print(rr)
                print(tp)
                p = int(f(rr[0]))
                print(&#39;p = &#39;,p)
                ok = True
                return
        except:
            pass
        return
    
    print(&#39;idx&#39;,idx)
    if leak&amp;(1&lt;&lt;(255-idx))==0:
        pq_xor(tp[:idx]+&#39;1&#39;+tp[idx+1:], tq[:idx]+&#39;1&#39;+tq[idx+1:], idx+1)
        pq_xor(tp[:idx]+&#39;0&#39;+tp[idx+1:], tq[:idx]+&#39;0&#39;+tq[idx+1:], idx+1)
    else:
        pq_xor(tp[:idx]+&#39;1&#39;+tp[idx+1:], tq[:idx]+&#39;0&#39;+tq[idx+1:], idx+1)
        pq_xor(tp[:idx]+&#39;0&#39;+tp[idx+1:], tq[:idx]+&#39;1&#39;+tq[idx+1:], idx+1)
    return

ok = False
cnt = 0
tp = tq = &#39;1&#39;+&#39;0&#39;*255
pq_xor(tp,tq, 1)
 
p = 64760524083545528318139240449356269097871629401328435356643510319660757701117
d = gmpy2.invert(e,p-1)
 
m2 = pow(c,d,p)
#3939513057628514533900105670644286436358199
flag2 = long_to_bytes(int(m2))
</code></pre>
<pre><code class="python"># flag1
p = 64760524083545528318139240449356269097871629401328435356643510319660757701117
E = EllipticCurve(Zmod(p),[114514,1919810])
e_ = inverse_mod(e,E.order())
G = e_ * E(P)
flag1 = long_to_bytes(int(G.xy()[0]))

print(flag1 + flag2)
</code></pre>
<h2 id="pading"><a href="#pading" class="headerlink" title="pading"></a>pading</h2><pre><code class="python">from Crypto.Util.number import *
import gmpy2
flag = b&#39;SHCTF&#123;********&#125;&#39;
assert len(flag) == 39
p = getPrime(512)
q = getPrime(512)
n = p * q
e = 0x3
pad = b&#39;a_easy_problem&#39;
c = pow(bytes_to_long(flag + pad),e,n)
print(f&#39;n = &#123;n&#125;&#39;)
print(f&#39;c = &#123;c&#125;&#39;)
&#39;&#39;&#39;
n = 88925266725790614176978985153637789080822030175282904715598493945895245166667653623506950637695577885515323428031007445721031625346904589773583755621369569539894646842301921582373643494813568764645514457347651475434655240168639797455429889319467717602197149735488558521980460060971030679001002737135989081379
c = 40163555624762340348570041191695482551610811286979685240673956204942190516868172042695831494716564410916937575793882661653526327850762355731766806531988424567396935008184593724634876174527495473578185969597195591837668991934008858114117407190127266840961661399395026531441718314388523035556743694153616077176
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<p>flag有点长，然后加了pad，但是pad已经给了，所以未知部分并不太长，符合coopersmith的条件。</p>
<pre><code class="python">from Crypto.Util.number import *

n = 88925266725790614176978985153637789080822030175282904715598493945895245166667653623506950637695577885515323428031007445721031625346904589773583755621369569539894646842301921582373643494813568764645514457347651475434655240168639797455429889319467717602197149735488558521980460060971030679001002737135989081379
c = 40163555624762340348570041191695482551610811286979685240673956204942190516868172042695831494716564410916937575793882661653526327850762355731766806531988424567396935008184593724634876174527495473578185969597195591837668991934008858114117407190127266840961661399395026531441718314388523035556743694153616077176
e = 0x3
pad = b&#39;a_easy_problem&#39;
PR.&lt;x&gt; = PolynomialRing(Zmod(n))
f = (x * 256 ** len(pad) + bytes_to_long(pad)) ** e - c
f = f.monic()
flag = f.small_roots(X=2 ** (39 * 8),beta=0.9,epsilon=0.03)
print(long_to_bytes(int(flag[0])))
</code></pre>
<h2 id="worde很大"><a href="#worde很大" class="headerlink" title="worde很大"></a>worde很大</h2><pre><code class="python">import gmpy2
from Crypto.Util.number import *
from enc import flag

m = bytes_to_long(flag)
p = getPrime(512)
q = getPrime(512)
n = p*q
e = getPrime(200)
d = gmpy2.invert(e,(p-1)*(q-1))
dp = d % (p-1)
c = pow(m,e,n)

print(f&quot;n = &#123;n&#125;&quot;)
print(f&quot;c = &#123;c&#125;&quot;)
print(f&quot;e = &#123;e&#125;&quot;)
print(f&quot;dp = &#123;dp&#125;&quot;)
&#39;&#39;&#39;
n = 115515571898174876218981859001454931605004972716977243469287394127512192363779470526054603716588099414019450006763757394190630930013648641786077436827746642661876619161637860418155678831315591087881465046824187409384523515896714190346462537788892486637416398025444806700379252307786369246845716404989752501389
c = 59022951400084401571296619763940304204631986982336332929632858883229505121317947890813288669173525619680320041372238944401947604215052939676594219177499970268852001305969409553072936766450801645767881017660967972861188714032933418524965669752906319830827483817966088130951093441496850545961357957507699583831
e = 1486959049663531472143038905223841284171772922831872838976599
dp = 2634722143918242121374646336711378512559772003469465687575508203789099196127320294411489576184834945221184222436264461306770774475661140034746877513780759
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

n = 115515571898174876218981859001454931605004972716977243469287394127512192363779470526054603716588099414019450006763757394190630930013648641786077436827746642661876619161637860418155678831315591087881465046824187409384523515896714190346462537788892486637416398025444806700379252307786369246845716404989752501389
c = 59022951400084401571296619763940304204631986982336332929632858883229505121317947890813288669173525619680320041372238944401947604215052939676594219177499970268852001305969409553072936766450801645767881017660967972861188714032933418524965669752906319830827483817966088130951093441496850545961357957507699583831
e = 1486959049663531472143038905223841284171772922831872838976599
dp = 2634722143918242121374646336711378512559772003469465687575508203789099196127320294411489576184834945221184222436264461306770774475661140034746877513780759

p = gmpy2.gcd(pow(3,e*dp,n)-3,n)
q = n//p
phi = (p-1)*(q-1)
d = gmpy2.invert(e,phi)
m = pow(c,d,n)
flag = long_to_bytes(m)
print(flag)
</code></pre>
<p>W</p>
]]></content>
      <categories>
        <category>比赛小屋</category>
      </categories>
  </entry>
  <entry>
    <title>2024 newstar</title>
    <url>/2024/10/22/6ddd94e3/</url>
    <content><![CDATA[<h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><pre><code class="pyth">#As a freshman starting in 2024, you should know something about XOR, so this task is for you to sign in.

from pwn import xor
#The Python pwntools library has a convenient xor() function that can XOR together data of different types and lengths
from Crypto.Util.number import bytes_to_long

key = b&#39;New_Star_CTF&#39;
flag=&#39;flag&#123;*******************&#125;&#39;

m1 = bytes_to_long(bytes(flag[:13], encoding=&#39;utf-8&#39;))
m2 = flag[13:]

c1 = m1 ^ bytes_to_long(key)
c2 = xor(key, m2)
print(&#39;c1=&#39;,c1)
print(&#39;c2=&#39;,c2)

&#39;&#39;&#39;
c1= 8091799978721254458294926060841
c2= b&#39;;:\x1c1&lt;\x03&gt;*\x10\x11u;&#39;
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

c1= 8091799978721254458294926060841
c2= b&#39;;:\x1c1&lt;\x03&gt;*\x10\x11u;&#39;
key = b&#39;New_Star_CTF&#39;

m1 = c1 ^ bytes_to_long(key)
m2 = bytes_to_long(c2) ^ bytes_to_long(key)
print(long_to_bytes(m1))
print(long_to_bytes(m2))
# flag&#123;0ops!_you_know_XOR!&#125;
</code></pre>
<h1 id="base"><a href="#base" class="headerlink" title="base"></a>base</h1><p>随波逐流梭哈</p>
<p><img src="/C:/Users\Y\AppData\Roaming\Typora\typora-user-images\image-20241020155629854.png" alt="image-20241020155629854"></p>
<h1 id="一眼秒了"><a href="#一眼秒了" class="headerlink" title="一眼秒了"></a>一眼秒了</h1><pre><code class="python">from Crypto.Util.number import *
from gmpy2 import *
from serct import flag
p = getPrime(512)
q = getPrime(512)
n = p*q
m = bytes_to_long(flag)
e = 65537
c = powmod(m, e, n)
print(n)
print(c)

# 52147017298260357180329101776864095134806848020663558064141648200366079331962132411967917697877875277103045755972006084078559453777291403087575061382674872573336431876500128247133861957730154418461680506403680189755399752882558438393107151815794295272358955300914752523377417192504702798450787430403387076153
# 48757373363225981717076130816529380470563968650367175499612268073517990636849798038662283440350470812898424299904371831068541394247432423751879457624606194334196130444478878533092854342610288522236409554286954091860638388043037601371807379269588474814290382239910358697485110591812060488786552463208464541069
</code></pre>
<p>exp:</p>
<p>yafu分解n</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

n =52147017298260357180329101776864095134806848020663558064141648200366079331962132411967917697877875277103045755972006084078559453777291403087575061382674872573336431876500128247133861957730154418461680506403680189755399752882558438393107151815794295272358955300914752523377417192504702798450787430403387076153
c = 48757373363225981717076130816529380470563968650367175499612268073517990636849798038662283440350470812898424299904371831068541394247432423751879457624606194334196130444478878533092854342610288522236409554286954091860638388043037601371807379269588474814290382239910358697485110591812060488786552463208464541069
e = 65537

q = 7221289171488727827673517139597844534869368289455419695964957239047692699919030405800116133805855968123601433247022090070114331842771417566928809956045093
p = 7221289171488727827673517139597844534869368289455419695964957239047692699919030405800116133805855968123601433247022090070114331842771417566928809956044421
phi = (p-1)*(q-1)
d = inverse(e,phi)
m = pow(c,d,n)
print(long_to_bytes(m))

# flag&#123;9cd4b35a-affc-422a-9862-58e1cc3ff8d2&#125;
</code></pre>
<h1 id="Strange-King"><a href="#Strange-King" class="headerlink" title="Strange King"></a>Strange King</h1><pre><code class="python">c = &#39;ksjr&#123;EcxvpdErSvcDgdgEzxqjql&#125;&#39;
shift = 5
result = &quot;&quot;
for i in c:
    if i.isalpha():
        start = ord(&#39;A&#39;) if i.isupper() else ord(&#39;a&#39;)
        result += chr((ord(i) - start - shift) % 26 + start)
    else:
        result += i
    shift += 2
print(result)
</code></pre>
<h1 id="这是几次方？-疑惑！"><a href="#这是几次方？-疑惑！" class="headerlink" title="这是几次方？ 疑惑！"></a>这是几次方？ 疑惑！</h1><pre><code class="python">from Crypto.Util.number import *


flag = b&#39;flag&#123;*****&#125;&#39;
p = getPrime(512)
q = getPrime(512)
n = p*q
e = 65537

m = bytes_to_long(flag)
c = pow(m, e, n)

hint = p^e + 10086

print(&quot;c =&quot;, c)
print(&quot;[n, e] =&quot;, [n, e])
print(&quot;hint =&quot;, hint)
&#39;&#39;&#39;
c = 36513006092776816463005807690891878445084897511693065366878424579653926750135820835708001956534802873403195178517427725389634058598049226914694122804888321427912070308432512908833529417531492965615348806470164107231108504308584954154513331333004804817854315094324454847081460199485733298227480134551273155762
[n, e] = [124455847177872829086850368685666872009698526875425204001499218854100257535484730033567552600005229013042351828575037023159889870271253559515001300645102569745482135768148755333759957370341658601268473878114399708702841974488367343570414404038862892863275173656133199924484523427712604601606674219929087411261, 65537]
hint = 12578819356802034679792891975754306960297043516674290901441811200649679289740456805726985390445432800908006773857670255951581884098015799603908242531673390
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

c = 36513006092776816463005807690891878445084897511693065366878424579653926750135820835708001956534802873403195178517427725389634058598049226914694122804888321427912070308432512908833529417531492965615348806470164107231108504308584954154513331333004804817854315094324454847081460199485733298227480134551273155762
[n, e] = [124455847177872829086850368685666872009698526875425204001499218854100257535484730033567552600005229013042351828575037023159889870271253559515001300645102569745482135768148755333759957370341658601268473878114399708702841974488367343570414404038862892863275173656133199924484523427712604601606674219929087411261, 65537]
hint = 12578819356802034679792891975754306960297043516674290901441811200649679289740456805726985390445432800908006773857670255951581884098015799603908242531673390

p = hint ^ (10086+e)
q = n // p
phi = (p - 1) * (q - 1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
</code></pre>
<h1 id="Since-you-konw-something"><a href="#Since-you-konw-something" class="headerlink" title="Since you konw something"></a>Since you konw something</h1><p>先尝试一下flag{</p>
<pre><code class="python">from pwn import xor
from Crypto.Util.number import long_to_bytes

flag_head = &#39;flag&#123;&#39;
c=218950457292639210021937048771508243745941011391746420225459726647571
guess_key = xor(long_to_bytes(c), flag_head)
print(guess_key)
# b&quot;nsnsnL2gVcf/xKa&#125;1MQ8z@m&#39;aa1`t&quot;
</code></pre>
<p>可以看到，<code>key</code> 的前一部分是重复的 <code>ns</code>，所以猜测key是ns</p>
<pre><code class="python">from Crypto.Util.number import *
from pwn import xor

c=218950457292639210021937048771508243745941011391746420225459726647571
key = &#39;ns&#39;
m = xor(long_to_bytes(c), key)
print(m)
</code></pre>
<h1 id="Just-one-and-more-than-two"><a href="#Just-one-and-more-than-two" class="headerlink" title="Just one and more than two"></a>Just one and more than two</h1><pre><code class="python">from Crypto.Util.number import *

flag = b&#39;flag&#123;?????&#125;&#39;
m1 = bytes_to_long(flag[:len(flag)//2])
m2 = bytes_to_long(flag[len(flag)//2:])
e = 65537
p, q, r= (getPrime(512) for _ in range(3))
N=p*q*r
c1 = pow(m1, e, p)
c2 = pow(m2, e, N)

print(f&#39;p=&#123;p&#125;\nq=&#123;q&#125;\nr=&#123;r&#125;\nc1=&#123;c1&#125;\nc2=&#123;c2&#125;&#39;)

&#39;&#39;&#39;
p=11867061353246233251584761575576071264056514705066766922825303434965272105673287382545586304271607224747442087588050625742380204503331976589883604074235133
q=11873178589368883675890917699819207736397010385081364225879431054112944129299850257938753554259645705535337054802699202512825107090843889676443867510412393
r=12897499208983423232868869100223973634537663127759671894357936868650239679942565058234189535395732577137079689110541612150759420022709417457551292448732371
c1=8705739659634329013157482960027934795454950884941966136315983526808527784650002967954059125075894300750418062742140200130188545338806355927273170470295451
c2=1004454248332792626131205259568148422136121342421144637194771487691844257449866491626726822289975189661332527496380578001514976911349965774838476334431923162269315555654716024616432373992288127966016197043606785386738961886826177232627159894038652924267065612922880048963182518107479487219900530746076603182269336917003411508524223257315597473638623530380492690984112891827897831400759409394315311767776323920195436460284244090970865474530727893555217020636612445
&#39;&#39;&#39;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

p=11867061353246233251584761575576071264056514705066766922825303434965272105673287382545586304271607224747442087588050625742380204503331976589883604074235133
q=11873178589368883675890917699819207736397010385081364225879431054112944129299850257938753554259645705535337054802699202512825107090843889676443867510412393
r=12897499208983423232868869100223973634537663127759671894357936868650239679942565058234189535395732577137079689110541612150759420022709417457551292448732371
c1=8705739659634329013157482960027934795454950884941966136315983526808527784650002967954059125075894300750418062742140200130188545338806355927273170470295451
c2=1004454248332792626131205259568148422136121342421144637194771487691844257449866491626726822289975189661332527496380578001514976911349965774838476334431923162269315555654716024616432373992288127966016197043606785386738961886826177232627159894038652924267065612922880048963182518107479487219900530746076603182269336917003411508524223257315597473638623530380492690984112891827897831400759409394315311767776323920195436460284244090970865474530727893555217020636612445
e = 65537

d1 = gmpy2.invert(e, p - 1)
m1 = pow(c1, d1, p)

d2 = gmpy2.invert(e, (p - 1) * (q - 1) * (r - 1))
m2 = pow(c2, d2, p * q * r)
print(long_to_bytes(m1) + long_to_bytes(m2))
</code></pre>
<h1 id="茶里茶气"><a href="#茶里茶气" class="headerlink" title="茶里茶气"></a>茶里茶气</h1><pre><code class="python">from Crypto.Util.number import *

flag = &quot;flag&#123;*****&#125;&quot;
assert len( flag ) == 25

a = &quot;&quot;
for i in flag:
    a += hex(ord(i))[2:]
l = int(a,16).bit_length()
print(&quot;l  =&quot; , l )

v0 = int(a,16)&gt;&gt;(l//2)
v1 = int(a,16)-(v0&lt;&lt;(l//2))
p = getPrime(l//2+10)

v2 = 0
derta = 462861781278454071588539315363
v3 = 489552116384728571199414424951
v4 = 469728069391226765421086670817
v5 = 564098252372959621721124077407
v6 = 335640247620454039831329381071
assert v1 &lt; p and v0 &lt; p and derta &lt; p and v3 &lt; p and v4 &lt; p and v5 &lt; p and v6 &lt; p 

for i in range(32):
    v1 += (v0+v2) ^ ( 8*v0 + v3 ) ^ ( (v0&gt;&gt;7) + v4 ) ; v1 %= p
    v0 += (v1+v2) ^ ( 8*v1 + v5 ) ^ ( (v1&gt;&gt;7) + v6 ) ; v0 %= p
    v2 += derta ; v2 %= p

print( &quot;p  =&quot; , p  )
print( &quot;v0 =&quot; , v0 )
print( &quot;v1 =&quot; , v1 )

&quot;&quot;&quot;
l  = 199
p  = 446302455051275584229157195942211
v0 = 190997821330413928409069858571234
v1 = 137340509740671759939138452113480
&quot;&quot;&quot;
</code></pre>
<p>exp:</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

v2 = 0
delta = 462861781278454071588539315363
v3 = 489552116384728571199414424951
v4 = 469728069391226765421086670817
v5 = 564098252372959621721124077407
v6 = 335640247620454039831329381071
l  = 199
p  = 446302455051275584229157195942211
v0 = 190997821330413928409069858571234
v1 = 137340509740671759939138452113480

for i in range( 32 ):
    v2 += delta 
    v2 %= p

for i in range(32):
    v2 -= delta ; v2 %= p
    v0 -= (v1+v2) ^ ( 8*v1 + v5 ) ^ ( (v1&gt;&gt;7) + v6 ) ; v0 %= p
    v1 -= (v0+v2) ^ ( 8*v0 + v3 ) ^ ( (v0&gt;&gt;7) + v4 ) ; v1 %= p

a = hex((v0&lt;&lt;((l//2))) + v1)[2:]

flag = &quot;&quot;
for i in range(0,len(a),2):
    flag += chr(int(a[i]+a[i+1],16))

print(flag)
# flag&#123;f14gg9_te2_1i_7ea_7&#125;
</code></pre>
]]></content>
      <categories>
        <category>比赛小屋</category>
      </categories>
  </entry>
  <entry>
    <title>2024 源鲁杯</title>
    <url>/2024/10/22/7314e54a/</url>
    <content><![CDATA[<h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="Round-1-break"><a href="#Round-1-break" class="headerlink" title="[Round 1] break"></a>[Round 1] break</h2><pre><code class="python">from Crypto.Util.number import *
from flag import FLAG
import random
from gmpy2 import *
p = getPrime(1024)
q = getPrime(1024)
n = p * q
phi = (p-1) * (q-1)
e = random.randint(55555,66666)
while (GCD(e,phi) != 1):
  e = random.randint(55555,66666)
d = invert(e, phi)
m = bytes_to_long(FLAG.encode())
c = pow(m,e,n)
with open(&#39;1.txt&#39;,&#39;w&#39;) as f:
  f.write(&quot;c = &quot; + str(c)+&quot;\n&quot;)
  f.write(&quot;p = &quot; + str(p)+&quot;\n&quot;)
  f.write(&quot;q = &quot; + str(q)+&quot;\n&quot;)

  
c = 2924474039245207571198784141495689937992753969132480503242933533024162740004938423057237165017818906240932582715571015311615140080805023083962661783117059081563515779040295926885648843373271315827557447038547354198633841318619550200065416569879422309228789074212184023902170629973366868476512892731022218074481334467704848598178703915477912059538625730030159772883926139645914921352787315268142917830673283253131667111029720811149494108036204927030497411599878456477044315081343437693246136153310194047948564341148092314660072088671342677689405603317615027453036593857501070187347664725660962477605859064071664385456
p = 112201812592436732390795120344111949417282805598314874949132199714697698933980025001138515893011073823715376332558632580563147885418631793000008453933543935617128269371275964779672888059389120797503550397834151733721290859419396400302434404551112484195071653351729447294368676427327217463094723449293599543541
q = 177020901129489152716203177604566447047904210970788458377477238771801463954823395388149502481778049515384638107090852884561335334330598757905074879935774091890632735202395688784335456371467073899458492800214225585277983419966028073512968573622161412555169766112847647015717557828009246475428909355149575012613
</code></pre>
<p>exp：</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

c = 2924474039245207571198784141495689937992753969132480503242933533024162740004938423057237165017818906240932582715571015311615140080805023083962661783117059081563515779040295926885648843373271315827557447038547354198633841318619550200065416569879422309228789074212184023902170629973366868476512892731022218074481334467704848598178703915477912059538625730030159772883926139645914921352787315268142917830673283253131667111029720811149494108036204927030497411599878456477044315081343437693246136153310194047948564341148092314660072088671342677689405603317615027453036593857501070187347664725660962477605859064071664385456
p = 112201812592436732390795120344111949417282805598314874949132199714697698933980025001138515893011073823715376332558632580563147885418631793000008453933543935617128269371275964779672888059389120797503550397834151733721290859419396400302434404551112484195071653351729447294368676427327217463094723449293599543541
q = 177020901129489152716203177604566447047904210970788458377477238771801463954823395388149502481778049515384638107090852884561335334330598757905074879935774091890632735202395688784335456371467073899458492800214225585277983419966028073512968573622161412555169766112847647015717557828009246475428909355149575012613

n = p * q
phi = (p - 1) * (q - 1)
for e in range(55555,66666):
  if gmpy2.gcd(e, phi) == 1:
    d = inverse(e, phi)
    m = pow(c, d, n)
    flag = long_to_bytes(m)
    if b&#39;YTCTF&#123;&#39; in flag:
      print(flag)
</code></pre>
<h2 id="Round-1-ezrsa"><a href="#Round-1-ezrsa" class="headerlink" title="[Round 1] ezrsa"></a>[Round 1] ezrsa</h2><pre><code class="python">import libnum
from Crypto.Util.number import *
fp = open(&quot;/flag&quot;,&quot;r&quot;)
flag = fp.read()
fp.close()
m = libnum.s2n(flag)
p = libnum.generate_prime(512)
q = libnum.generate_prime(512)
e = 65537
n = p * q
h = 20240918
yl = bytes_to_long(b&quot;YLCTF&quot;)
hint = pow(h + p * yl, e, n)
c = pow(m, e, n)
print(&quot;hint=&quot;, hint)
print(&quot;n=&quot;, n)
print(&quot;c=&quot;, c)

hint= 44837585844827676538820075636317805991872726004889511084485899377451561157076751927238420032978911456501367101724399819752360311785355614730133475304740270703311169047229809355115973003860023663677847350101793234354736985402942122692355838109371098253861142186568951509025702684958533988511889558751345930646
n= 117201731446737360829592872706707776611105864909089421158705592410176386026159004480580211785267807936235568143282278084483082533211437997639577701282827818581073606232140235105172984636315320305499713798908892564418462531482967482506713793788870683676327379631426743829797967781333154679506576275536780968337
c= 20235445022257525003295720373859615330559778096045790110385970095030136938454089521097905075616521818340976601280174798397273081721622834633163972161339830532238169666185944427438919465030313850573258636665490769094197374128852861073593841628820111023996471977892552012293456235598758849448970997516153048181
   
</code></pre>
<p>exp：</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

hint= 44837585844827676538820075636317805991872726004889511084485899377451561157076751927238420032978911456501367101724399819752360311785355614730133475304740270703311169047229809355115973003860023663677847350101793234354736985402942122692355838109371098253861142186568951509025702684958533988511889558751345930646
n= 117201731446737360829592872706707776611105864909089421158705592410176386026159004480580211785267807936235568143282278084483082533211437997639577701282827818581073606232140235105172984636315320305499713798908892564418462531482967482506713793788870683676327379631426743829797967781333154679506576275536780968337
c= 20235445022257525003295720373859615330559778096045790110385970095030136938454089521097905075616521818340976601280174798397273081721622834633163972161339830532238169666185944427438919465030313850573258636665490769094197374128852861073593841628820111023996471977892552012293456235598758849448970997516153048181
h = 20240918
yl = bytes_to_long(b&quot;YLCTF&quot;)
e = 65537

kp = h ** e - hint
p = gmpy2.gcd(kp, n)
q = n // p
phi = (p-1) * (q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
</code></pre>
<h2 id="Round-1-signrsa"><a href="#Round-1-signrsa" class="headerlink" title="[Round 1] signrsa"></a>[Round 1] signrsa</h2><pre><code class="python">import libnum
from Crypto.Util.number import *
fp = open(&quot;/flag&quot;,&quot;r&quot;)
flag = fp.read()
fp.close()
m = bytes_to_long(bytes(flag.encode()))
n1 = 18674375108313094928585156581138941368570022222190945461284402673204018075354069827186085851309806592398721628845336840532779579197302984987661547245423180760958022898546496524249201679543421158842103496452861932183144343315925106154322066796612415616342291023962127055311307613898583850177922930685155351380500587263611591893137588708003711296496548004793832636078992866149115453883484010146248683416979269684197112659302912316105354447631916609587360103908746719586185593386794532066034112164661723748874045470225129298518385683561122623859924435600673501186244422907402943929464694448652074412105888867178867357727
n2 = 20071978783607427283823783012022286910630968751671103864055982304683197064862908267206049336732205051588820325894943126769930029619538705149178241710069113634567118672515743206769333625177879492557703359178528342489585156713623530654319500738508146831223487732824835005697932704427046675392714922683584376449203594641540794557871881581407228096642417744611261557101573050163285919971711214856243031354845945564837109657494523902296444463748723639109612438012590084771865377795409000586992732971594598355272609789079147061852664472115395344504822644651957496307894998467309347038349470471900776050769578152203349128951
e = 65537
c = pow(m,e,n1)
c = pow(c,e,n2)
print(c)


14278669943908050100319498897125454055916743831141500320699723388390778092794757480665689042296712614568915437636966052507665125827634046285837189932754333876193378905432473275319766762677422458275248351586552885403227545819741962220327369299905180143087520932248289352630857886011347018076180877009166874784235109771988479229575534671338306602166505648254925650752786199977491269575507711912768684457568527241320706090586656072357746256553990790381405466800016723076140271152809036690135114101083629426538828800151612553033895213649844251111541856101433720742079744857204118679748727140204060939504276688380792732026
</code></pre>
<p>exp：</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

c = 14278669943908050100319498897125454055916743831141500320699723388390778092794757480665689042296712614568915437636966052507665125827634046285837189932754333876193378905432473275319766762677422458275248351586552885403227545819741962220327369299905180143087520932248289352630857886011347018076180877009166874784235109771988479229575534671338306602166505648254925650752786199977491269575507711912768684457568527241320706090586656072357746256553990790381405466800016723076140271152809036690135114101083629426538828800151612553033895213649844251111541856101433720742079744857204118679748727140204060939504276688380792732026
n1 = 18674375108313094928585156581138941368570022222190945461284402673204018075354069827186085851309806592398721628845336840532779579197302984987661547245423180760958022898546496524249201679543421158842103496452861932183144343315925106154322066796612415616342291023962127055311307613898583850177922930685155351380500587263611591893137588708003711296496548004793832636078992866149115453883484010146248683416979269684197112659302912316105354447631916609587360103908746719586185593386794532066034112164661723748874045470225129298518385683561122623859924435600673501186244422907402943929464694448652074412105888867178867357727
n2 = 20071978783607427283823783012022286910630968751671103864055982304683197064862908267206049336732205051588820325894943126769930029619538705149178241710069113634567118672515743206769333625177879492557703359178528342489585156713623530654319500738508146831223487732824835005697932704427046675392714922683584376449203594641540794557871881581407228096642417744611261557101573050163285919971711214856243031354845945564837109657494523902296444463748723639109612438012590084771865377795409000586992732971594598355272609789079147061852664472115395344504822644651957496307894998467309347038349470471900776050769578152203349128951
e = 65537
q = gmpy2.gcd(n1,n2)
print(q)
# 122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137
p1 = n1 // q
p2 = n2 // q
d1 = gmpy2.invert(e,(q-1)*(p1-1))
d2 = gmpy2.invert(e,(q-1)*(p2-1))
m = pow(c,d2,n2)
m = pow(m,d1,n1)
print(long_to_bytes(m))
</code></pre>
<h2 id="Round-1-threecry"><a href="#Round-1-threecry" class="headerlink" title="[Round 1] threecry"></a>[Round 1] threecry</h2><pre><code class="python">from Crypto.Util.number import *
import sympy
fp = open(&quot;/flag&quot;,&quot;r&quot;)
flag = fp.read()
fp.close()
a=getPrime(512)
p=sympy.nextprime(13*a)
q=sympy.prevprime(25*a)
number2=p*q

def crypto01(number1, number2, number3):
  number4 = 1
  while number2 &gt; 0:
    if number2 % 2:
      number4 = (number4 * number1) % number3
    number1 = number1 ** 2 % number3
    number2 //= 2
  return number4

def crypto02(number1, number2):
  number3 = number1
  number4 = number2
  giao = 1
  giaogiao = 0
  while number4 &gt; 0:
    number7 = number3 // number4
    giao, giaogiao = giaogiao, giao - giaogiao*number7
    number3, number4 = number4, number3 - number4*number7
  while giao&lt;0:
    giao = giao + number2
  return giao

def crypto03(number1, number2, number3):
  number4 = crypto01(number3, number1, number2)
  return number4

def crypto05(number1,number2):
  return pow(number1,0xe18e,number2)






number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683
number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
number3 = int.from_bytes(flag[0:19].encode(&quot;utf-8&quot;), &quot;big&quot;)
number4 = int.from_bytes(flag[19:].encode(&quot;utf-8&quot;), &quot;big&quot;)
print(number2)
print(crypto03(number1, number2, number3))
print(crypto05(number4,number2))

number2= 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
crypto03= 14373795657143529033761004251777858926564889749219353034130523327864116284934725115187300659977425650062651499175892843228625049136301153969272984340576119192564293510121057488643554356615361120443551797262307931041976560923293571689829940369031724374707930465635225647261476224887383446792069041533605034648613
crypto05= 7772482186078812631432622568297197054576428252546088737955199212754911979975803308001014257786938603809013026999223979902449592167311798157219508889195406336904171485606510152622085844791594864275966779261835424506907410089308489930047114988049206331326522035273415066985467150860348510800186330805455506786970
</code></pre>
<p>exp：</p>
<pre><code class="python">from Crypto.Util.number import *
import gmpy2

c1 = 14373795657143529033761004251777858926564889749219353034130523327864116284934725115187300659977425650062651499175892843228625049136301153969272984340576119192564293510121057488643554356615361120443551797262307931041976560923293571689829940369031724374707930465635225647261476224887383446792069041533605034648613
c2 = 7772482186078812631432622568297197054576428252546088737955199212754911979975803308001014257786938603809013026999223979902449592167311798157219508889195406336904171485606510152622085844791594864275966779261835424506907410089308489930047114988049206331326522035273415066985467150860348510800186330805455506786970
number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683
number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
e = 0xe18e
a = gmpy2.iroot(number2 // (13 * 25), 2)[0]
while number2 % gmpy2.next_prime( 13 * a) != 0:
  a = gmpy2.next_prime(a)

p = gmpy2.next_prime(13 * a)
q = number2 // p
phi = (p - 1) * (q - 1)
d1 = gmpy2.invert(number1, phi)
m1 = pow(c1, d1, number2)
flag1 = long_to_bytes(m1)

t = gmpy2.gcd(e, phi)
d2 = inverse(e // t, phi)
m2 = pow(c2, d2, number2)
m2 = gmpy2.iroot(m2, 2)[0]
flag2 = long_to_bytes(m2)

print(flag1 + flag2)
</code></pre>
<h2 id="Round1-r-A-3"><a href="#Round1-r-A-3" class="headerlink" title="[Round1] r(A)&#x3D;3"></a>[Round1] r(A)&#x3D;3</h2><pre><code class="python">import numpy as np
from scipy.linalg import solve
from pwn import *

# 创建到挑战服务器的远程连接
# challenge.yuanloo.com:38276
conn = remote(&quot;challenge.yuanloo.com&quot;, 34397)

# 循环300次，处理每次挑战
for i in range(300):
  print(i)
  conn.recvuntil(&quot;:\n&quot;) # 等待直到接收到特定的字符串

  # 初始化存储方程系数和常数项的列表
  coefficients = [[], [], []]
  constants = []

  # 接收三个线性方程
  for _ in range(3):
    equation = conn.recvline().decode().strip()
    parts = equation.split()

    # 解析每个方程的系数和常数项
    for part in parts[:-1]:
      if &#39;*&#39; in part:
        coef, var = part.split(&#39;*&#39;)
        coefficients[_].append(int(coef))

    constants.append(int(parts[-1]))

  # 将系数和常数项转换为numpy数组
  A = np.array(coefficients)
  b = np.array(constants)

  # 解线性方程组
  x = solve(A, b)

  # 发送解到的变量值给服务器
  conn.sendline(str(int(x[0])))
  conn.sendline(str(int(x[1])))
  conn.sendline(str(int(x[2])))

# 启动交互式shell
conn.interactive()
</code></pre>
]]></content>
      <categories>
        <category>比赛小屋</category>
      </categories>
  </entry>
</search>
