<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>C语言基础知识 | Puplovoi&#39;s blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="C语言基础知识 | Puplovoi&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="friends">
<meta property="og:url" content="https://puplovoi.github.io/friends/index.html">
<meta property="og:site_name" content="Puplovoi&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-10-03T08:04:35.000Z">
<meta property="article:modified_time" content="2024-10-03T08:04:35.459Z">
<meta property="article:author" content="puplovoi">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="false" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>puplovoi</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/puplovoi"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:2921642540@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="C语言">
            
            C语言
            
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="7">
<input type="hidden" id="yelog_site_word_count" value="16.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="search shortcut key i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="switch to outline view shortcut key w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="return"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="case sensitive"></i>
            <i class="iconfont icon-tag" data-title="label"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">outline</div>
            <i class="iconfont icon-list" data-title="switch to article list"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="All C语言 "
           href="/2025/01/02/22d02b26/"
           data-tag=""
           data-author="puplovoi" >
            <span class="post-title" title="C语言代码">C语言代码</span>
            <span class="post-date" title="2025-01-02 14:55:07">2025/01/02</span>
        </a>
        
        
        <a  class="All C语言 "
           href="/2025/01/01/612af661/"
           data-tag=""
           data-author="puplovoi" >
            <span class="post-title" title="C语言编程题">C语言编程题</span>
            <span class="post-date" title="2025-01-01 02:52:02">2025/01/01</span>
        </a>
        
        
        <a  class="All C语言 "
           href="/2025/01/01/a2206cf4/"
           data-tag=""
           data-author="puplovoi" >
            <span class="post-title" title="C语言—排序+查找">C语言—排序+查找</span>
            <span class="post-date" title="2025-01-01 02:43:10">2025/01/01</span>
        </a>
        
        
        <a  class="All C语言 "
           href="/2024/12/30/7f2a165f/"
           data-tag=""
           data-author="puplovoi" >
            <span class="post-title" title="C语言基础知识">C语言基础知识</span>
            <span class="post-date" title="2024-12-30 20:17:38">2024/12/30</span>
        </a>
        
        
        <a  class="All C语言 "
           href="/2024/12/30/e9f78b55/"
           data-tag=""
           data-author="puplovoi" >
            <span class="post-title" title="C语言（9-12章）">C语言（9-12章）</span>
            <span class="post-date" title="2024-12-30 00:11:08">2024/12/30</span>
        </a>
        
        
        <a  class="All C语言 "
           href="/2024/12/29/720c3174/"
           data-tag=""
           data-author="puplovoi" >
            <span class="post-title" title="C语言（7-8章）">C语言（7-8章）</span>
            <span class="post-date" title="2024-12-29 23:37:06">2024/12/29</span>
        </a>
        
        
        <a  class="All C语言 "
           href="/2024/12/29/7379d433/"
           data-tag=""
           data-author="puplovoi" >
            <span class="post-title" title="C语言（1-6章）">C语言（1-6章）</span>
            <span class="post-date" title="2024-12-29 23:22:09">2024/12/29</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="Toggle full screen shortcut key s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-C语言基础知识" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">C语言基础知识</h1>
    
    <div class="article-meta">
        
        
        <span class="author"><a>puplovoi</a></span>
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="C语言">C语言</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-01-01 02:32:55'>2024-12-30 20:17</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:9.7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">C 语言基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81C-%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">一、C 程序基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90"><span class="toc-text">（一）程序构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0%EF%BC%88main%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">（二）主函数（main函数）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">二、基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B4%E5%9E%8B"><span class="toc-text">（一）整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%88%E5%B0%8F%E6%95%B0%EF%BC%89"><span class="toc-text">（二）浮点型（小数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%97%E7%AC%A6%E5%9E%8B%EF%BC%88char%EF%BC%89"><span class="toc-text">（三）字符型（char）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89sizeof"><span class="toc-text">（四）sizeof</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="toc-text">三、变量与常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%98%E9%87%8F"><span class="toc-text">（一）变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E9%87%8F"><span class="toc-text">（二）常量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">四、运算符与表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（一）算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（二）关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（三）逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%88-%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9F%AD%E8%B7%AF%E7%89%B9%E6%80%A7"><span class="toc-text">逻辑与（&amp;&amp;）运算符的短路特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%88%96%EF%BC%88-%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9F%AD%E8%B7%AF%E7%89%B9%E6%80%A7"><span class="toc-text">逻辑或（||）运算符的短路特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（四）赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（五）自增自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（六）条件运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（七）位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">（八）逗号运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C"><span class="toc-text">五、输入输出操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">（一）标准输入输出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">（二）字符输入输出函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">六、控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">（一）顺序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-text">（二）选择结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">（三）循环结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-text">（四）跳转语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">七、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">（一）数组定义与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-text">（二）数组元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%BA%94%E7%94%A8"><span class="toc-text">（三）一维数组应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">（四）二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-text">（五）数组与函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-text">（六）数组与指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">八、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">（一）字符串的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">（二） 字符串的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-text">（三）字符串的输入与输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">（四） 字符串操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-text">（五）字符串与指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">（六）注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">九、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">（一）函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-text">（二） 函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">（三） 函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">（四）参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">（五）返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-text">（六）递归函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">十、结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-text">（一）结构体定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE"><span class="toc-text">（二）结构体成员访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">（三）结构体初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">（四）结构体作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97"><span class="toc-text">（五）结构体嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-text">（六） 结构体数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">（七）结构体与内存对齐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">十一、预处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">（一）宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%88-include%EF%BC%89"><span class="toc-text">（二）文件包含（#include）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-text">（三）条件编译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%A4%A7%E5%AE%B6%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8A%A0%E6%88%91%E5%BE%AE%E4%BF%A1%E9%97%AE%E6%88%91"><span class="toc-text">如果大家还有什么问题，可以加我微信问我</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-语言基础知识"><a href="#C-语言基础知识" class="headerlink" title="C 语言基础知识"></a>C 语言基础知识</h1><blockquote>
<p>计算机要处理的数据（诸如数字、文字、符号、图形、音频、视频等）是以二进制的形式存放在内存中的。<br>我们将8个比特（Bit）称为一个字节（Byte），并将字节作为最小的可操作单元</p>
</blockquote>
<h2 id="一、C-程序基本结构"><a href="#一、C-程序基本结构" class="headerlink" title="一、C 程序基本结构"></a>一、C 程序基本结构</h2><h3 id="（一）程序构成"><a href="#（一）程序构成" class="headerlink" title="（一）程序构成"></a>（一）程序构成</h3><ol>
<li>头文件<ul>
<li>概念与作用</li>
<li>包含方式（<code>#include &lt;文件名&gt;</code>与<code>#include &quot;文件名&quot;</code>）</li>
</ul>
</li>
<li>函数<ul>
<li>定义与组成（函数头、函数体）</li>
<li>分类（标准库函数、用户自定义函数）</li>
</ul>
</li>
</ol>
<h3 id="（二）主函数（main函数）"><a href="#（二）主函数（main函数）" class="headerlink" title="（二）主函数（main函数）"></a>（二）主函数（<code>main</code>函数）</h3><ol>
<li><strong>程序执行起点</strong></li>
<li>定义形式<ul>
<li><code>int main()</code></li>
<li><code>int main(int argc, char *argv[])</code></li>
</ul>
</li>
<li><strong>返回值意义</strong></li>
</ol>
<pre><code class="c">#include &lt;stdio.h&gt;
int main() &#123;
    printf(&quot;Hello, World!\n&quot;);
    return 0;
&#125;
</code></pre>
<pre><code class="markdown">以下关于 C 语言主函数的说法正确的是（ ）
A. 一个 C 程序可以有多个主函数
B. 主函数名可以随意命名
C. 主函数是程序执行的起点
D. 主函数必须有参数
</code></pre>
<h2 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h2><h3 id="（一）整型"><a href="#（一）整型" class="headerlink" title="（一）整型"></a>（一）整型</h3><ul>
<li><p>分类：<code>short</code>（短整型）、<code>int</code>（整型）、<code>long</code>（长整型）、<code>long long</code>（更长的长整型），用于表示整数。</p>
<ul>
<li><p>二进制</p>
<p>二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头。</p>
</li>
<li><p>八进制</p>
<p>八进制由 <code>0~7</code> 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母 o）。</p>
</li>
<li><p>十进制</p>
<p>十进制由 <code>0~9</code> 十个数字组成，没有任何前缀，和平时的书写格式一样</p>
</li>
<li><p>十六进制</p>
<p>十六进制由数字 <code>0~9</code>、字母 <code>A~F</code> 或 <code>a~f</code>（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头</p>
<p>二进制数、八进制数和十六进制数的输出</p>
<table>
<thead>
<tr>
<th></th>
<th>short</th>
<th>int</th>
<th>long</th>
</tr>
</thead>
<tbody><tr>
<td>八进制</td>
<td>%ho</td>
<td>%o</td>
<td>%lo</td>
</tr>
<tr>
<td>十进制</td>
<td>%hd</td>
<td>%d</td>
<td>%ld</td>
</tr>
<tr>
<td>十六进制</td>
<td>%hx 或者 %hX</td>
<td>%x 或者 %X</td>
<td>%lx 或者 %lX</td>
</tr>
</tbody></table>
<p>十六进制数字的表示用到了英文字母，有大小写之分，要在格式控制符中体现出来：</p>
<ul>
<li>%hx、%x 和 %lx 中的x小写，表明以小写字母的形式输出十六进制数；</li>
<li>%hX、%X 和 %lX 中的X大写，表明以大写字母的形式输出十六进制数。</li>
</ul>
</li>
</ul>
</li>
<li><p>取值范围与内存占用：不同整型类型占用不同字节数，如在常见系统中，<code>short</code>通常占 2 字节，<code>int</code>占 4 字节，<code>long</code>占 4 字节（在某些系统可能占 8 字节），<code>long long</code>占 8 字节。取值范围也因字节数不同而有所差异，例如<code>int</code>的取值范围大致为 -2147483648 到 2147483647。</p>
</li>
<li><p>修饰符：<code>signed</code>（有符号）为默认修饰符，可表示正负值；<code>unsigned</code>（无符号）只能表示非负值，能扩大正数的表示范围。例如，<code>unsigned int</code>可表示 0 到 4294967295 之间的数。</p>
<p>C语言规定，把内存的最高位作为符号位。在符号位中，<strong>用 0 表示正数，用 1 表示负数</strong>。</p>
<p>无符号数可以以八进制、十进制和十六进制的形式输出，它们对应的格式控制符分别为：</p>
<table>
<thead>
<tr>
<th></th>
<th>unsigned short</th>
<th>unsigned int</th>
<th>unsigned long</th>
</tr>
</thead>
<tbody><tr>
<td>八进制</td>
<td>%ho</td>
<td>%o</td>
<td>%lo</td>
</tr>
<tr>
<td>十进制</td>
<td>%hu</td>
<td>%u</td>
<td>%lu</td>
</tr>
<tr>
<td>十六进制</td>
<td>%hx 或者 %hX</td>
<td>%x 或者 %X</td>
<td>%lx 或者 %lX</td>
</tr>
</tbody></table>
<pre><code class="c">unsigned int a = -1;     //a = 4294967295
</code></pre>
</li>
</ul>
<h3 id="（二）浮点型（小数）"><a href="#（二）浮点型（小数）" class="headerlink" title="（二）浮点型（小数）"></a>（二）浮点型（小数）</h3><ul>
<li><p>分类：<code>float</code>（单精度浮点型）、<code>double</code>（双精度浮点型），用于表示带有小数部分的数值。</p>
</li>
<li><p>精度与内存占用：<code>float</code>一般占用 4 字节内存，精度约为 6 - 7 位有效数字；<code>double</code>占用 8 字节内存，精度约为 15 - 16 位有效数字。例如，<code>float f = 3.14f;</code>（注意<code>float</code>常量后需加<code>f</code>），<code>double d = 3.141592653589793;</code>。</p>
</li>
<li><p>C语言中小数的指数形式为：aEn 或 aen</p>
<p>a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；E或e是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。</p>
<ul>
<li>2.1E5 &#x3D; 2.1×10 5，其中 2.1 是尾数，5 是指数。</li>
<li>3.7E-2 &#x3D; 3.7×10-2，其中 3.7 是尾数，-2 是指数。</li>
<li>0.5E7 &#x3D; 0.5×10 7，其中 0.5 是尾数，7 是指数。</li>
</ul>
</li>
<li><p>小数的输出</p>
<ul>
<li><strong>%f 以十进制形式输出 float 类型</strong>。</li>
<li><strong>%lf 以十进制形式输出 double 类型</strong>。</li>
<li>%e 以指数形式输出 float 类型，输出结果中的 e 小写。</li>
<li>%E 以指数形式输出 float 类型，输出结果中的 E 大写。</li>
<li>%le 以指数形式输出 double 类型，输出结果中的 e 小写。</li>
<li>%lE 以指数形式输出 double 类型，输出结果中的 E 大写。</li>
</ul>
</li>
</ul>
<pre><code>底边为a,高为h，都是整型，下列哪个选项能算出三角形面积（      ）
A.s = 1/2*a*h
B.s = 1/(2*a*h)
C.s = 1.0/(2*a*h)
D.s = a*h/2
</code></pre>
<h3 id="（三）字符型（char）"><a href="#（三）字符型（char）" class="headerlink" title="（三）字符型（char）"></a>（三）字符型（char）</h3><ul>
<li><p>字符存储：使用 ASCII 码存储单个字符，每个字符对应一个唯一的整数值，如<code>&#39;A&#39;</code>对应 65，<code>&#39;a&#39;</code>对应 97。</p>
</li>
<li><p>字符常量与变量：字符常量用单引号括起来，如<code>&#39;A&#39;</code>、<code>&#39;5&#39;</code>；字符变量用于存储字符常量，如<code>char ch = &#39;A&#39;;</code>。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main()
&#123;
    char c = &#39;a&#39;;
    printf(&quot;%d\n&quot;,c);
    printf(&quot;%d\n&quot;,&#39;a&#39;);
    printf(&quot;%c\n&quot;,c);
    printf(&quot;%c\n&quot;,&#39;a&#39;); 
    return 0;
&#125;
</code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>说 明</th>
<th>字符型</th>
<th>短整型</th>
<th>整型</th>
<th>长整型</th>
<th>单精度浮点型</th>
<th>双精度浮点型</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>char</td>
<td>short</td>
<td>int</td>
<td>long</td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td>长 度</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="（四）sizeof"><a href="#（四）sizeof" class="headerlink" title="（四）sizeof"></a>（四）sizeof</h3><p><strong><code>sizeof</code>是操作符，不是函数！</strong></p>
<p>用于获取数据类型或变量占用字节数，如<code>sizeof(int)</code>返回<code>int</code>类型占用字节数，<code>int num; sizeof num</code>可获取变量<code>num</code>占用字节数（变量名可省略括号）。不同数据类型在不同系统中占用字节数可能不同，一般<code>short</code>占 2 字节，<code>int</code>占 4 字节，<code>long</code>占 8 字节，<code>float</code>占 4 字节，<code>double</code>占 8 字节，<code>char</code>占 1 字节。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main() &#123;
    int a = 1;
    printf(&quot;%d\n&quot;,sizeof a);          //4
    printf(&quot;%d\n&quot;,sizeof(int));       //4
&#125;
</code></pre>
<h2 id="三、变量与常量"><a href="#三、变量与常量" class="headerlink" title="三、变量与常量"></a>三、变量与常量</h2><h4 id="（一）变量"><a href="#（一）变量" class="headerlink" title="（一）变量"></a>（一）变量</h4><ol>
<li>初始化<ul>
<li>int a;创造了一个变量 a，这个过程叫做变量定义。</li>
<li>a&#x3D;123;把 123 交给了变量 a，这个过程叫做给变量赋值。</li>
<li><strong>未初始化变量值不确定，使用易致错误</strong>。</li>
</ul>
</li>
<li>作用域与生命周期<ul>
<li><strong>局部变量</strong>：在函数内或代码块内定义，作用域限于此，如函数内<code>int b = 10;</code>。</li>
<li><strong>全局变量</strong>：在函数外部定义，作用域从定义处到文件尾，可被多函数使用。</li>
<li><strong>自动变量</strong>：局部变量默认存储类型，进入作用域创建，离开销毁。</li>
<li><strong>静态变量</strong>：用<code>static</code>修饰，局部静态变量值会保留，生命周期为程序运行期。</li>
</ul>
</li>
</ol>
<h4 id="（二）常量"><a href="#（二）常量" class="headerlink" title="（二）常量"></a>（二）常量</h4><ol>
<li><p>字面常量</p>
<ul>
<li><p><strong>整型常量</strong>：如<code>10</code>、<code>-20</code>，有不同进制表示，如<code>0x10</code>（十六进制）。</p>
</li>
<li><p><strong>浮点型常量</strong>：<code>3.14</code>、<code>2.718</code>，<code>float</code>型需加<code>f</code>后缀，如<code>3.14f</code>。</p>
</li>
<li><p><strong>字符常量</strong>：单引号括起单个字符，如<code>&#39;A&#39;</code>，存储为 ASCII 码值。</p>
</li>
<li><p><strong>字符串常量</strong>：双引号括起字符序列，如<code>&quot;Hello&quot;</code>，自动加<code>\0</code>结束符。</p>
</li>
</ul>
</li>
<li><p>符号常量</p>
<ul>
<li><strong><code>#define</code>定义宏常量</strong>：<code>#define PI 3.14159</code>，预处理时替换。</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;
#define A 3+4
int main() &#123;
    int a = 2 * A / A + A;
    printf(&quot;%d\n&quot;, a);
    return 0;
&#125;// 运行结果为？？？
</code></pre>
<ul>
<li><strong><code>const</code>修饰常量</strong>：<code>const int MAX = 100;</code>，定义后值不可改。</li>
</ul>
</li>
</ol>
<h2 id="四、运算符与表达式"><a href="#四、运算符与表达式" class="headerlink" title="四、运算符与表达式"></a>四、运算符与表达式</h2><h3 id="（一）算术运算符"><a href="#（一）算术运算符" class="headerlink" title="（一）算术运算符"></a>（一）算术运算符</h3><ol>
<li><p><strong>基本运算</strong>：加<code>+</code>、减<code>-</code>、乘<code>*</code>、除<code>/</code>、取余<code>%</code>。</p>
</li>
<li><p><strong>优先级</strong>：先乘除取余，后加减。</p>
</li>
<li><p><strong>运算特性</strong>：整数除得整数，浮点数除更精确。</p>
</li>
<li><p>当除号两端<strong>都是整数</strong>时，即使定义的变量是浮点数，得出的结果也会是整数（或被截取为整数），除非其中一方<strong>带有小数</strong>。</p>
<p>示例：</p>
</li>
</ol>
<pre><code class="C">int a = 9 / 2;
printf(&quot;%d\n&quot;, a);
float b = 9 / 2;
printf(&quot;%f\n&quot;, b);
float c = 9 / 2.0;
printf(&quot;%f\n&quot;, c);
</code></pre>
<h3 id="（二）关系运算符"><a href="#（二）关系运算符" class="headerlink" title="（二）关系运算符"></a>（二）关系运算符</h3><ol>
<li><p><strong>比较符号</strong>：大于<code>&gt;</code>、小于<code>&lt;</code>、大于等于<code>&gt;=</code>、小于等于<code>&lt;=</code>、等于<code>==</code>、不等于<code>!=</code>。</p>
</li>
<li><p><strong>结果真假</strong>：成立为真（非 0），不成立为假（0）。</p>
</li>
</ol>
<blockquote>
<p>C语言中，<strong>非零即真</strong></p>
</blockquote>
<h3 id="（三）逻辑运算符"><a href="#（三）逻辑运算符" class="headerlink" title="（三）逻辑运算符"></a>（三）逻辑运算符</h3><ol>
<li><p><strong>逻辑符号</strong>：逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>、逻辑非<code>!</code>。</p>
</li>
<li><p><strong>求值规则</strong>：<code>&amp;&amp;</code>两边真才真，<code>||</code>有一真即真，<code>!</code>取反。</p>
<h4 id="逻辑与（-）运算符的短路特性"><a href="#逻辑与（-）运算符的短路特性" class="headerlink" title="逻辑与（&amp;&amp;）运算符的短路特性"></a><strong>逻辑与（<code>&amp;&amp;</code>）运算符的短路特性</strong></h4><ol>
<li><p><strong>特性描述</strong>：对于逻辑与表达式 <code>A &amp;&amp; B</code>，先计算子表达式 <code>A</code>。如果 <code>A</code> 的值为 <code>0</code>（假），由于整个逻辑与表达式的结果必定为 <code>0</code>，无论 <code>B</code> 的值是什么，C 语言将不会再计算子表达式 <code>B</code>，直接得出整个表达式的结果为 <code>0</code>。只有当 <code>A</code> 的值为非 <code>0</code>（真）时，才会继续计算子表达式 <code>B</code>，以确定整个逻辑与表达式的最终结果。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main()
&#123;
    int a = 0;
    int b = 0;
    int result = a &amp;&amp; (b++ &gt; 0);
    if (result)
        printf(&quot;a = %d, b = %d, result = %d\n&quot;, a, b, result);
    else
        printf(&quot;Error!&quot;);
    return 0;
&#125;
// result = (b++ &gt; 0) &amp;&amp; a;    结果如何？
// result = (++b &gt; 0) &amp;&amp; a;    结果如何？
</code></pre>
<p>在上述代码中，<code>a</code> 的值为 <code>0</code>，当计算到 <code>a &amp;&amp; (b++ &gt; 0)</code> 时，由于 <code>a</code> 为 <code>0</code>，根据逻辑与的短路特性，不再计算 <code>b++ &gt; 0</code> 这个子表达式，所以 <code>b</code> 的值不会增加。最终输出结果为 <code>a = 0, b = 5, result = 0</code>。</p>
</li>
</ol>
<h4 id="逻辑或（-）运算符的短路特性"><a href="#逻辑或（-）运算符的短路特性" class="headerlink" title="逻辑或（||）运算符的短路特性"></a><strong>逻辑或（<code>||</code>）运算符的短路特性</strong></h4><ol>
<li><p><strong>特性描述</strong>：对于逻辑或表达式 <code>A || B</code>，先计算子表达式 <code>A</code>。如果 <code>A</code> 的值为非 <code>0</code>（真），由于整个逻辑或表达式的结果必定为 <code>1</code>，无论 <code>B</code> 的值是什么，C 语言将不会再计算子表达式 <code>B</code>，直接得出整个表达式的结果为 <code>1</code>。只有当 <code>A</code> 的值为 <code>0</code>（假）时，才会继续计算子表达式 <code>B</code>，以确定整个逻辑或表达式的最终结果。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main() &#123;
    int a = 5;
    int b = 0;
    int result = a || (b++ &gt; 0);
    if (result)
        printf(&quot;a = %d, b = %d, result = %d\n&quot;, a, b, result);
    else
        printf(&quot;Error!&quot;);
    return 0;
&#125;
// result = (b++ &gt; 0) || a;    结果如何？
// result = (++b &gt; 0) || a;    结果如何？
</code></pre>
</li>
</ol>
<p>在这段代码中，<code>a</code> 的值为 <code>5</code>，当计算 <code>a || (b++ &gt; 0)</code> 时，因为 <code>a</code> 为非 <code>0</code>，根据逻辑或的短路特性，不再计算 <code>b++ &gt; 0</code> 这个子表达式，所以 <code>b</code> 的值不会增加。最终输出结果为 <code>a = 5, b = 0, result = 1</code>。</p>
</li>
</ol>
<h3 id="（四）赋值运算符"><a href="#（四）赋值运算符" class="headerlink" title="（四）赋值运算符"></a>（四）赋值运算符</h3><ol>
<li><p><strong>简单赋值</strong>：<code>=</code>将右侧值赋给左侧变量。</p>
</li>
<li><p><strong>复合赋值</strong>：如<code>+=</code>、<code>-=</code>等简化写法。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main()
&#123;
    int a = 10;
    a += a *= a -= 6;
    printf(&quot;%d&quot;, a);
    return 0;
&#125;
</code></pre>
</li>
</ol>
<h3 id="（五）自增自减运算符"><a href="#（五）自增自减运算符" class="headerlink" title="（五）自增自减运算符"></a>（五）自增自减运算符</h3><ol>
<li><p><strong>前置后置</strong>：前置先增减再用值，后置先用值再增减。</p>
</li>
<li><p><strong>表达式作用</strong>：改变变量值并参与运算。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main()
&#123;
    int a = 4;
    printf(&quot;%d\n&quot;, a++);
    printf(&quot;%d\n&quot;, ++a);
    int b = 4;
    printf(&quot;%d\n&quot;, (b++) * (a++));
    printf(&quot;%d\n&quot;, (++b) * (++a));
    return 0;
&#125;
</code></pre>
</li>
</ol>
<h3 id="（六）条件运算符"><a href="#（六）条件运算符" class="headerlink" title="（六）条件运算符"></a>（六）条件运算符</h3><ol>
<li><p><strong>语法结构</strong>：<code>表达式1? 表达式2 : 表达式3</code>。</p>
</li>
<li><p><strong>条件求值</strong>：表达式 1 真取表达式 2 值，假取表达式 3 值。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main() &#123;
    int a = 10, b = 20;
    int max;

    // 使用条件运算符找出较大值
    max = (a &gt; b)? a : b;

    printf(&quot;较大值是: %d\n&quot;, max);
    return 0;
&#125;
</code></pre>
<pre><code class="c">max = (a &gt; b)? a : b;
int max;
if (a &gt; b) &#123;
    max = a;
&#125; else &#123;
    max = b;
&#125;
</code></pre>
</li>
</ol>
<h3 id="（七）位运算符"><a href="#（七）位运算符" class="headerlink" title="（七）位运算符"></a>（七）位运算符</h3><ol>
<li>**按位与 &amp;**：对应位都为 1 才得 1。</li>
<li>**按位或 |**：对应位有 1 就得 1。</li>
<li><strong>按位异或 ^</strong>：对应位不同得 1。</li>
<li><strong>按位取反～</strong>：0 变 1，1 变 0。</li>
<li><strong>移位运算</strong>：左移<code>&lt;&lt;</code>、右移<code>&gt;&gt;</code>，移动二进制位。</li>
</ol>
<h3 id="（八）逗号运算符"><a href="#（八）逗号运算符" class="headerlink" title="（八）逗号运算符"></a>（八）逗号运算符</h3><ol>
<li><strong>运算顺序</strong>：从左到右依次求值。</li>
<li><strong>最终结果</strong>：取最后一个表达式的值。</li>
</ol>
<h2 id="五、输入输出操作"><a href="#五、输入输出操作" class="headerlink" title="五、输入输出操作"></a>五、输入输出操作</h2><h3 id="（一）标准输入输出函数"><a href="#（一）标准输入输出函数" class="headerlink" title="（一）标准输入输出函数"></a>（一）标准输入输出函数</h3><ol>
<li><code>printf</code>函数<ul>
<li><strong>格式控制</strong>：含普通字符与格式说明符，如<code>%d</code> <code>%f</code>等。</li>
<li><strong>精度控制</strong>：如<code>%.2f</code>控制浮点数小数位。</li>
<li><strong>宽度控制</strong>：<ul>
<li><code>%md</code>指定输出宽度m。</li>
<li><code>%m.nf</code> 指定输出宽度m，保留n位小数</li>
</ul>
</li>
</ul>
</li>
<li><code>scanf</code>函数<ul>
<li><strong>格式匹配</strong>：格式说明符要与输入数据类型一致。</li>
<li><strong>取址操作</strong>：变量前用<code>&amp;</code>获取地址存输入值。</li>
<li><strong>缓冲区</strong>：注意输入缓冲区残留数据影响。</li>
</ul>
</li>
</ol>
<h3 id="（二）字符输入输出函数"><a href="#（二）字符输入输出函数" class="headerlink" title="（二）字符输入输出函数"></a>（二）字符输入输出函数</h3><ol>
<li><code>getchar</code>函数<ul>
<li><strong>功能</strong>：从标准输入读单个字符。</li>
<li><strong>缓冲区</strong>：会读取缓冲区残留字符。</li>
</ul>
</li>
<li><code>putchar</code>函数<ul>
<li><strong>功能</strong>：向标准输出写单个字符。</li>
</ul>
</li>
</ol>
<h2 id="六、控制结构"><a href="#六、控制结构" class="headerlink" title="六、控制结构"></a>六、控制结构</h2><h3 id="（一）顺序结构"><a href="#（一）顺序结构" class="headerlink" title="（一）顺序结构"></a>（一）顺序结构</h3><p>程序按语句先后顺序依次执行，无分支与循环，是程序最基础执行方式。</p>
<h3 id="（二）选择结构"><a href="#（二）选择结构" class="headerlink" title="（二）选择结构"></a>（二）选择结构</h3><ol>
<li><p><strong>if语句</strong>：</p>
<ul>
<li><code>if (表达式) 语句;</code>，当表达式值为非零（即逻辑真）时，执行其后语句；若为零（逻辑假），则跳过该语句。例如：</li>
</ul>
<pre><code class="c">int num = 10;
if (num &gt; 5) &#123;
    printf(&quot;数字大于 5\n&quot;); 
&#125;
</code></pre>
<ul>
<li><strong>if - else 形式</strong>：<code>if (表达式) 语句1; else 语句2;</code>，表达式为真执行语句 1，为假执行语句 2。例如：</li>
</ul>
<pre><code class="c">int num = 3;
if (num &gt; 5) &#123;
    printf(&quot;数字大于 5\n&quot;); 
&#125; else &#123;
    printf(&quot;数字小于等于 5\n&quot;); 
&#125;
</code></pre>
<ul>
<li><strong>多重 if - else 嵌套</strong>：适用于多种条件判断场景。格式为：</li>
</ul>
<pre><code class="c">if (表达式1) &#123;
    语句1; 
&#125; else if (表达式2) &#123;
    语句2; 
&#125; else &#123;
    语句3; 
&#125;
</code></pre>
<p>  例如判断成绩等级：</p>
<pre><code class="c">int score = 85;
if (score &gt;= 90) &#123;
    printf(&quot;等级为 A\n&quot;); 
&#125; else if (score &gt;= 80) &#123;
    printf(&quot;等级为 B\n&quot;); 
&#125; else if (score &gt;= 70) &#123;
    printf(&quot;等级为 C\n&quot;); 
&#125; else &#123;
    printf(&quot;等级为 D\n&quot;); 
&#125;
</code></pre>
</li>
<li><p><strong>switch - case 语句</strong></p>
</li>
</ol>
<ul>
<li><strong>适用场景</strong>：用于多分支选择，分值条件多为整型常量或者字符型常量。</li>
<li><strong>基本结构</strong>：</li>
</ul>
<pre><code class="c">switch (表达式) &#123;
    case 常量1:
        语句1;
        break;
    case 常量2:
        语句2;
        break;
    default:
        语句3;
&#125;
</code></pre>
<ul>
<li>表达式的值与各 <code>case</code> 后的常量表达式值比较，若相等则执行对应语句，<code>break</code> 用于跳出 <code>switch</code> 结构。若都不相等，执行 <code>default</code> 后的语句（<code>default</code> 可选）。例如：</li>
</ul>
<pre><code class="c">int num = 3;
switch (num) &#123;
    case 1:
        printf(&quot;1\n&quot;);
        break;
    case 2:
        printf(&quot;2\n&quot;);
        break;
    case 3:
        printf(&quot;3\n&quot;);
        break;
    default:
        printf(&quot;4\n&quot;);
&#125;
</code></pre>
<h3 id="（三）循环结构"><a href="#（三）循环结构" class="headerlink" title="（三）循环结构"></a>（三）循环结构</h3><ol>
<li><p><code>for</code>循环</p>
<ul>
<li><strong>语法</strong>：</li>
</ul>
<pre><code class="c">for (初始化; 条件判断; 更新) 
&#123;
    循环体;
&#125;
</code></pre>
<ul>
<li><p><strong>三部分</strong>：</p>
<ul>
<li><p>首先执行初始化表达式，仅执行一次，用于初始化循环控制变量。</p>
</li>
<li><p>接着判断条件表达式，若为真（非零值），则执行循环体语句；若为假（零值），循环结束，执行 <code>for</code> 循环之后的语句。</p>
</li>
<li><p>执行完循环体后，执行更新表达式，通常用于修改循环控制变量，之后再次判断条件表达式，重复上述过程。</p>
</li>
</ul>
</li>
<li><p><strong>嵌套</strong>：<code>for</code>循环内包含<code>for</code>循环，实现多层循环。</p>
</li>
<li><p><strong>应用场景</strong>：适用于已知循环次数的场景。例如，要遍历数组元素</p>
</li>
</ul>
<pre><code class="c">int arr[5] = &#123;1, 2, 3, 4, 5&#125;;
for (int i = 0; i &lt; 5; i++) &#123;
    printf(&quot;%d &quot;, arr[i]);
&#125;
</code></pre>
</li>
<li><p><code>while</code>循环</p>
<ul>
<li><strong>语法</strong>：</li>
</ul>
<pre><code class="c">while (条件)
&#123;
    循环体;
&#125;
</code></pre>
<ul>
<li><strong>判断</strong>：条件为真反复执行循环体，需避免死循环。</li>
<li><strong>应用场景</strong>：适用于不确定循环次数，但根据某个条件决定是否继续循环的场景。例如，从键盘读取整数，直到输入负数时停止</li>
</ul>
<pre><code class="c">int num;
while (1) &#123;
    printf(&quot;请输入一个整数: &quot;);
    scanf(&quot;%d&quot;, &amp;num);
    if (num &lt; 0) &#123;
        break;
    &#125;
    printf(&quot;输入的数是: %d\n&quot;, num);
&#125;
</code></pre>
</li>
<li><p><code>do - while</code>循环</p>
<ul>
<li><strong>语法</strong>：</li>
</ul>
<pre><code class="c">do &#123;
    循环体;
&#125; while (条件);
</code></pre>
<ul>
<li><p><strong>特点</strong>：先执行循环体，后判断条件，至少执行一次。与<code>while</code>循环判断顺序不同。</p>
</li>
<li><p><strong>应用场景</strong>：适用于至少要执行一次循环体的场景。例如，简单的菜单选择程序，无论用户输入是否正确，至少展示一次菜单</p>
</li>
</ul>
<pre><code class="c">int choice;
do &#123;
    printf(&quot;1. 选项1\n2. 选项2\n3. 退出\n请选择: &quot;);
    scanf(&quot;%d&quot;, &amp;choice);
    switch (choice) &#123;
        case 1:
            printf(&quot;你选择了选项1\n&quot;);
            break;
        case 2:
            printf(&quot;你选择了选项2\n&quot;);
            break;
        case 3:
            printf(&quot;退出程序\n&quot;);
            break;
        default:
            printf(&quot;无效选择，请重新输入\n&quot;);
    &#125;
&#125; while (choice!= 3);
</code></pre>
</li>
</ol>
<h3 id="（四）跳转语句"><a href="#（四）跳转语句" class="headerlink" title="（四）跳转语句"></a>（四）跳转语句</h3><ol>
<li><p><strong>break 语句</strong>：用于立即终止当前循环（<code>for</code>、<code>while</code>、<code>do - while</code>），跳出循环体，执行循环之后的语句。常与条件语句配合使用，提前结束循环。</p>
</li>
<li><p><strong>continue 语句</strong>：用于跳过本次循环中剩余的语句，直接开始下一次循环。即当执行到 <code>continue</code> 时，本次循环体中 <code>continue</code> 之后的语句不再执行，直接进行下一次循环的条件判断。</p>
</li>
<li><p><strong>goto 语句</strong>：可以无条件跳转到程序中指定的标号处。但由于 <code>goto</code> 语句可能使程序结构混乱，可读性变差，应谨慎使用。例如</p>
<pre><code class="c">int i = 0;
label:
if (i &lt; 5) &#123;
    printf(&quot;%d &quot;, i);
    i++;
    goto label;
&#125;
</code></pre>
</li>
</ol>
<h2 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h2><h3 id="（一）数组定义与初始化"><a href="#（一）数组定义与初始化" class="headerlink" title="（一）数组定义与初始化"></a>（一）数组定义与初始化</h3><ol>
<li><strong>定义</strong>：数组是相同数据类型元素的有序集合。语法为 <code>数据类型 数组名[数组大小];</code>，例如 <code>int numbers[5];</code> 定义了一个可容纳 5 个整数的数组。数组大小必须是常量表达式。</li>
<li>初始化<ul>
<li><strong>完全初始化</strong>：<code>int arr[3] = &#123;1, 2, 3&#125;;</code>，每个元素被明确赋值。</li>
<li><strong>部分初始化</strong>：<code>int arr[5] = &#123;1, 2&#125;;</code>，前两个元素被赋值为 1 和 2，其余元素自动初始化为 0（对于整型数组）。</li>
<li><strong>省略大小初始化</strong>：<code>int arr[] = &#123;4, 5, 6&#125;;</code>，数组大小由初始化元素个数确定，这里为 3。</li>
</ul>
</li>
</ol>
<h3 id="（二）数组元素访问"><a href="#（二）数组元素访问" class="headerlink" title="（二）数组元素访问"></a>（二）数组元素访问</h3><p>通过下标访问数组元素，下标从 0 开始。例如，对于 <code>int numbers[5];</code>，可通过 <code>numbers[0]</code> 访问第一个元素，<code>numbers[4]</code> 访问第五个元素。越界访问会导致未定义行为，如访问 <code>numbers[5]</code>。</p>
<h3 id="（三）一维数组应用"><a href="#（三）一维数组应用" class="headerlink" title="（三）一维数组应用"></a>（三）一维数组应用</h3><ol>
<li><p><strong>遍历数组</strong>：常使用 <code>for</code> 循环，如：</p>
<pre><code class="c">int arr[5] = &#123;1, 2, 3, 4, 5&#125;;
for (int i = 0; i &lt; 5; i++) &#123;
    printf(&quot;%d &quot;, arr[i]);
&#125;
</code></pre>
</li>
<li><p><strong>查找元素</strong>：在数组中查找特定值，可顺序遍历数组进行比较。</p>
<pre><code class="c">int target = 3;
int found = 0;
for (int i = 0; i &lt; 5; i++) &#123;
    if (arr[i] == target) &#123;
        found = 1;
        break;
    &#125;
&#125;
if (found) &#123;
    printf(&quot;Element found\n&quot;);
&#125; else &#123;
    printf(&quot;Element not found\n&quot;);
&#125;
</code></pre>
</li>
<li><p><strong>排序</strong>：常见的排序算法如冒泡排序、选择排序等可用于对一维数组进行排序。以冒泡排序为例：</p>
<pre><code class="c">void bubbleSort(int arr[], int n) &#123;
    for (int i = 0; i &lt; n - 1; i++) &#123;
        for (int j = 0; j &lt; n - i - 1; j++) &#123;
            if (arr[j] &gt; arr[j + 1]) &#123;
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="（四）二维数组"><a href="#（四）二维数组" class="headerlink" title="（四）二维数组"></a>（四）二维数组</h3><ol>
<li><p>定义与初始化</p>
<p>：二维数组可看作是数组的数组，定义语法为<code>数据类型 数组名[行数][列数];</code>，例如<code>int matrix[2][3];</code></p>
<p>。初始化方式有：</p>
<ul>
<li><strong>按行初始化</strong>：<code>int matrix1[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;</code></li>
<li><strong>连续初始化</strong>：<code>int matrix2[2][3] = &#123;1, 2, 3, 4, 5, 6&#125;;</code> 与按行初始化效果相同。</li>
</ul>
</li>
<li><p><strong>元素访问与遍历</strong>：通过两个下标访问元素，如 <code>matrix[0][1]</code>。遍历二维数组需要嵌套 <code>for</code> 循环：</p>
<pre><code class="c">for (int i = 0; i &lt; 2; i++) &#123;
    for (int j = 0; j &lt; 3; j++) &#123;
        printf(&quot;%d &quot;, matrix[i][j]);
    &#125;
    printf(&quot;\n&quot;);
&#125;
</code></pre>
</li>
</ol>
<h3 id="（五）数组与函数"><a href="#（五）数组与函数" class="headerlink" title="（五）数组与函数"></a>（五）数组与函数</h3><ol>
<li><p><strong>数组作为函数参数</strong>：数组作为参数传递给函数时，实际上传递的是数组首元素的地址。函数声明可以写成 <code>void func(int arr[], int size);</code> 或 <code>void func(int *arr, int size);</code>，<code>size</code> 用于指定数组大小。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
void printArray(int arr[], int size) &#123;
    for (int i = 0; i &lt; size; i++) &#123;
        printf(&quot;%d &quot;, arr[i]);
    &#125;
&#125;

int main() &#123;
    int numbers[5] = &#123;1, 2, 3, 4, 5&#125;;
    printArray(numbers, 5);
    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>返回数组的函数</strong>：C 语言中函数不能直接返回数组，但可以返回指向数组的指针。通常使用静态数组或动态内存分配来实现。例如：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 创建一个数组并返回指向该数组的指针
int* createArray() &#123;
    // 使用 malloc 函数动态分配内存，可存储 3 个 int 类型元素
    int *arr = (int *)malloc(3 * sizeof(int));
    if (arr == NULL) &#123;
        printf(&quot;Memory allocation failed!\n&quot;);
        return NULL;
    &#125;
    // 对分配的内存进行初始化
    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;
    return arr;
&#125;

int main() &#123;
    int *result = createArray();
    if (result!= NULL) &#123;
        for (int i = 0; i &lt; 3; i++) &#123;
            printf(&quot;%d &quot;, result[i]);
        &#125;
        // 释放动态分配的内存，避免内存泄漏
        free(result);
    &#125;
    return 0;
&#125;
</code></pre>
</li>
</ol>
<p>​	当使用 <code>malloc</code> 函数分配内存后，必须使用 <code>free</code> 函数释放内存，否则会导致内存泄漏，即程序占用的内存不断增加而不释放，最终可能耗尽系统内存。</p>
<h3 id="（六）数组与指针"><a href="#（六）数组与指针" class="headerlink" title="（六）数组与指针"></a>（六）数组与指针</h3><ol>
<li><p><strong>数组名与指针关系</strong>：数组名在表达式中会自动转换为指向首元素的指针。例如，对于 <code>int arr[5];</code>，<code>arr</code> 等价于 <code>&amp;arr[0]</code>。可以通过指针算术运算访问数组元素，如 <code>*(arr + 2)</code> 等价于 <code>arr[2]</code>。</p>
</li>
<li><p><strong>指针数组</strong>：是数组，其元素是指针。例如 <code>int *ptrArr[3];</code>，可用于存储多个指针，常用于处理多个字符串（字符串指针数组）。</p>
<ol>
<li><p>初始化</p>
<ul>
<li><strong>静态初始化</strong>：在声明指针数组时可以同时进行初始化。例如：</li>
</ul>
<pre><code class="c">int num1 = 10, num2 = 20, num3 = 30;
int *ptrArray[3] = &#123;&amp;num1, &amp;num2, &amp;num3&#125;;
</code></pre>
<p>  在此例中，<code>ptrArray</code> 数组的三个元素分别指向 <code>num1</code>、<code>num2</code> 和 <code>num3</code> 这三个整型变量。</p>
<ul>
<li><strong>动态初始化</strong>：通过动态分配内存来初始化指针数组的元素。例如：</li>
</ul>
<pre><code class="c">int **ptrArray = (int **)malloc(3 * sizeof(int *));
for (int i = 0; i &lt; 3; i++) &#123;
    ptrArray[i] = (int *)malloc(sizeof(int));
    *ptrArray[i] = i * 10;
&#125;
</code></pre>
<p>  上述代码先为指针数组本身分配内存，然后为每个指针元素分配内存，并赋值。</p>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><strong>处理字符串数组</strong>：指针数组常用于处理多个字符串。因为在 C 语言中，字符串本质上是以 <code>&#39;\0&#39;</code> 结尾的字符数组，而指针可以指向字符串的起始地址。例如：</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;
int main() &#123;
    char *strArray[3] = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;;
    for (int i = 0; i &lt; 3; i++) &#123;
        printf(&quot;%s\n&quot;, strArray[i]);
    &#125;
    return 0;
&#125;
</code></pre>
<p>  在这个例子中，<code>strArray</code> 是一个指针数组，每个元素指向一个字符串常量。通过遍历指针数组，可以方便地访问和操作这些字符串。</p>
<ul>
<li><strong>实现函数指针数组</strong>：函数指针也是一种指针，将函数指针存储在指针数组中，可以实现根据不同条件调用不同函数的功能。例如：</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;
int add(int a, int b) &#123; return a + b; &#125;
int subtract(int a, int b) &#123; return a - b; &#125;
int multiply(int a, int b) &#123; return a * b; &#125;
int main() &#123;
    int (*funcPtrArray[3])(int, int) = &#123;add, subtract, multiply&#125;;
    int result1 = funcPtrArray[0](3, 5);
    int result2 = funcPtrArray[1](7, 4);
    int result3 = funcPtrArray[2](2, 6);
    printf(&quot;Addition: %d\n&quot;, result1);
    printf(&quot;Subtraction: %d\n&quot;, result2);
    printf(&quot;Multiplication: %d\n&quot;, result3);
    return 0;
&#125;
</code></pre>
<p>在上述代码中，<code>funcPtrArray</code> 是一个函数指针数组，包含三个函数指针，分别指向 <code>add</code>、<code>subtract</code> 和 <code>multiply</code> 函数。通过数组索引，可以方便地调用不同的函数。</p>
<p>指针数组在处理需要多个指针的场景时非常灵活和高效，能够简化代码结构并提高程序的可维护性。</p>
</li>
</ol>
</li>
<li><p><strong>数组指针</strong>：是指针，指向数组。例如 <code>int (*arrPtr)[5];</code>，<code>arrPtr</code> 指向一个包含 5 个整数的数组。常用于二维数组的指针操作.</p>
<p>​	使用场景</p>
<ul>
<li><strong>二维数组操作</strong>：在 C 语言中，二维数组本质上是按行存储的一维数组。数组指针常用于处理二维数组，因为它可以更方便地控制内存访问。例如，假设有二维数组 <code>int arr[3][4];</code>，可以使用数组指针来遍历它：</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;
int main() &#123;
    int arr[3][4] = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125; &#125;;
    int (*ptr)[4] = arr; // 数组指针指向二维数组的首行
    for (int i = 0; i &lt; 3; i++) &#123;
        for (int j = 0; j &lt; 4; j++) &#123;
            printf(&quot;%d &quot;, *(*(ptr + i)+ j));
        &#125;
        printf(&quot;\n&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
<p>  在上述代码中，<code>ptr</code> 是一个指向包含 4 个 <code>int</code> 元素数组的指针，并初始化为 <code>arr</code> 的首地址。通过 <code>*(ptr + i)</code> 访问到第 <code>i</code> 行的地址，再通过 <code>*(*(ptr + i)+ j)</code> 访问到第 <code>i</code> 行第 <code>j</code> 列的元素。</p>
<ul>
<li><strong>作为函数参数</strong>：当二维数组作为函数参数传递时，使用数组指针作为参数类型可以更清晰地表达参数的含义。例如：</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;
void printArray(int (*arr)[4], int rows) &#123;
    for (int i = 0; i &lt; rows; i++) &#123;
        for (int j = 0; j &lt; 4; j++) &#123;
            printf(&quot;%d &quot;, *(*(arr + i)+ j));
        &#125;
        printf(&quot;\n&quot;);
    &#125;
&#125;
int main() &#123;
    int arr[3][4] = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125; &#125;;
    printArray(arr, 3);
    return 0;
&#125;
</code></pre>
<p>  在这个例子中，<code>printArray</code> 函数接受一个数组指针 <code>arr</code> 和行数 <code>rows</code> 作为参数，用于打印二维数组的内容。</p>
<p>  数组指针在处理多维数组以及需要明确指向数组的场景中非常有用，它提供了一种更高效、更直观的内存访问和数据处理方式。</p>
</li>
</ol>
<h2 id="八、字符串"><a href="#八、字符串" class="headerlink" title="八、字符串"></a>八、字符串</h2><h3 id="（一）字符串的表示"><a href="#（一）字符串的表示" class="headerlink" title="（一）字符串的表示"></a>（一）字符串的表示</h3><ul>
<li><strong>字符数组</strong>：C 语言中没有专门的字符串类型，通常使用字符数组来表示字符串。例如，<code>char str1[10] = &quot;Hello&quot;;</code> 定义了一个字符数组 <code>str1</code>，并初始化为字符串 <code>&quot;Hello&quot;</code>。注意，数组的大小要足够容纳字符串及其结束符 <code>&#39;\0&#39;</code>。</li>
<li><strong>字符串常量</strong>：字符串常量是用双引号括起来的字符序列，如 <code>&quot;world&quot;</code>。C 语言会自动在字符串常量的末尾添加一个空字符 <code>&#39;\0&#39;</code> 作为字符串的结束标志。例如，<code>&quot;world&quot;</code> 在内存中实际存储为 <code>&#123;&#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;\0&#39;&#125;</code>。</li>
</ul>
<h3 id="（二）-字符串的初始化"><a href="#（二）-字符串的初始化" class="headerlink" title="（二） 字符串的初始化"></a>（二） 字符串的初始化</h3><ul>
<li><strong>完全初始化</strong>：<code>char str2[6] = &#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;;</code> 这种方式明确地指定了每个字符，包括结束符 <code>&#39;\0&#39;</code>。</li>
<li><strong>部分初始化</strong>：<code>char str3[10] = &quot;Hi&quot;;</code> 这里只初始化了前两个字符和结束符，其余字符自动初始化为 <code>&#39;\0&#39;</code>。</li>
<li><strong>省略数组大小初始化</strong>：<code>char str4[] = &quot;Goodbye&quot;;</code> 编译器会根据初始化字符串的长度自动确定数组大小，这里数组大小为 8（包括 <code>&#39;\0&#39;</code>）。</li>
</ul>
<h3 id="（三）字符串的输入与输出"><a href="#（三）字符串的输入与输出" class="headerlink" title="（三）字符串的输入与输出"></a>（三）字符串的输入与输出</h3><ul>
<li><p>输出：</p>
<ul>
<li>使用 <code>printf</code> 函数，格式控制符 <code>%s</code> 用于输出字符串。例如，<code>printf(&quot;%s&quot;, str1);</code> 会输出 <code>str1</code> 所存储的字符串。</li>
<li><code>puts</code> 函数也可用于输出字符串，并且会在输出完字符串后自动换行。例如，<code>puts(str1);</code>。</li>
</ul>
</li>
<li><p>输入：</p>
<ul>
<li>使用 <code>scanf</code> 函数，<code>%s</code> 同样用于输入字符串。例如，<code>scanf(&quot;%s&quot;, str1);</code>。但要注意，<code>scanf</code> 在遇到空格、制表符或换行符时会停止读取，所以不能用于输入包含空格的字符串。</li>
</ul>
</li>
<li><p><code>gets</code> 函数（已不推荐使用，存在缓冲区溢出风险）可以读取包含空格的字符串，直到遇到换行符。例如，<code>gets(str1);</code>。推荐使用 <code>fgets</code> 函数替代 <code>gets</code>，<code>fgets(str1, sizeof(str1), stdin);</code>，<code>fgets</code> 会读取最多 <code>sizeof(str1) - 1</code> 个字符，避免缓冲区溢出。</p>
</li>
</ul>
<h3 id="（四）-字符串操作函数"><a href="#（四）-字符串操作函数" class="headerlink" title="（四） 字符串操作函数"></a>（四） 字符串操作函数</h3><ul>
<li><p><strong>字符串长度计算</strong>：<code>strlen</code> 函数用于计算字符串的长度（不包括结束符 <code>&#39;\0&#39;</code>）。例如，<code>int len = strlen(str1);</code>。</p>
</li>
<li><p>字符串复制：</p>
<ul>
<li><code>strcpy</code> 函数将一个字符串复制到另一个字符数组中。例如，<code>char dest[20]; strcpy(dest, str1);</code>。注意目标数组要足够大以容纳源字符串。</li>
<li><code>strncpy</code> 函数是 <code>strcpy</code> 的安全版本，它最多复制指定数量的字符。例如，<code>strncpy(dest, str1, sizeof(dest) - 1); dest[sizeof(dest) - 1] = &#39;\0&#39;;</code>，这样可以防止缓冲区溢出。</li>
</ul>
</li>
<li><p>字符串连接：</p>
<ul>
<li><code>strcat</code> 函数将一个字符串连接到另一个字符串的末尾。例如，<code>char str5[20] = &quot;Hello, &quot;; strcat(str5, &quot;world!&quot;);</code>。同样要确保目标数组有足够空间。</li>
<li><code>strncat</code> 函数是 <code>strcat</code> 的安全版本，它最多连接指定数量的字符。例如，<code>strncat(str5, &quot;world!&quot;, sizeof(str5) - strlen(str5) - 1);</code>。</li>
</ul>
</li>
<li><p><strong>字符串比较</strong>：<code>strcmp</code> 函数用于比较两个字符串。如果两个字符串相等，返回 0；如果第一个字符串小于第二个字符串，返回负数；如果第一个字符串大于第二个字符串，返回正数。例如，<code>int cmp = strcmp(str1, str2);</code>。<code>strncmp</code> 函数则是比较指定数量的字符。</p>
</li>
</ul>
<h3 id="（五）字符串与指针"><a href="#（五）字符串与指针" class="headerlink" title="（五）字符串与指针"></a>（五）字符串与指针</h3><ul>
<li><p>可以使用字符指针来操作字符串。例如，<code>char *ptr = &quot;Hello&quot;;</code> 这里 <code>ptr</code> 是一个指向字符串常量 <code>&quot;Hello&quot;</code> 的指针。可以通过指针来访问字符串中的字符，如 <code>printf(&quot;%c&quot;, *ptr);</code> 会输出 <code>H</code>。</p>
</li>
<li><p>当字符串作为函数参数传递时，实际上传递的是字符串的首地址（即指针）。例如：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
void printString(char *str) &#123;
    printf(&quot;%s\n&quot;, str);
&#125;
int main() &#123;
    char str[] = &quot;This is a test&quot;;
    printString(str);
    return 0;
&#125;
</code></pre>
</li>
</ul>
<h3 id="（六）注意事项"><a href="#（六）注意事项" class="headerlink" title="（六）注意事项"></a>（六）注意事项</h3><ul>
<li>始终要确保字符数组有足够的空间来存储字符串及其结束符 <code>&#39;\0&#39;</code>，否则会导致缓冲区溢出错误，这可能引发程序崩溃或安全漏洞。</li>
<li>在使用字符串操作函数时，要注意函数的返回值和参数要求，特别是涉及到缓冲区大小的参数，以避免错误。</li>
</ul>
<h2 id="九、函数"><a href="#九、函数" class="headerlink" title="九、函数"></a>九、函数</h2><h3 id="（一）函数定义"><a href="#（一）函数定义" class="headerlink" title="（一）函数定义"></a>（一）函数定义</h3><ul>
<li><strong>基本结构</strong>：由函数头和函数体组成。函数头包含函数返回类型、函数名和参数列表；函数体是实现具体功能的代码块，用花括号 <code>&#123;&#125;</code> 括起来。</li>
<li><strong>语法格式</strong>：</li>
</ul>
<pre><code class="c">返回类型 函数名(参数列表) &#123;
    // 函数体
    语句;
    return 返回值;
&#125;
</code></pre>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<pre><code class="c">int add(int a, int b) &#123;
    int sum = a + b;
    return sum;
&#125;
</code></pre>
<p>上述代码定义了一个名为 <code>add</code> 的函数，它接受两个 <code>int</code> 类型的参数 <code>a</code> 和 <code>b</code>，返回它们的和。</p>
<h3 id="（二）-函数声明"><a href="#（二）-函数声明" class="headerlink" title="（二） 函数声明"></a>（二） 函数声明</h3><ul>
<li><strong>作用</strong>：告诉编译器函数的名称、返回类型和参数类型，以便在调用函数之前让编译器知道如何处理该函数调用。</li>
<li><strong>语法格式</strong>：</li>
</ul>
<pre><code class="c">返回类型 函数名(参数列表);
</code></pre>
<ul>
<li><strong>示例</strong>：</li>
</ul>
<pre><code class="c">int add(int a, int b); // 函数声明
int main() &#123;
    int result = add(3, 5); // 函数调用
    return 0;
&#125;
int add(int a, int b) &#123; // 函数定义
    int sum = a + b;
    return sum;
&#125;
</code></pre>
<p>通常，函数声明放在源文件的开头或头文件中，函数定义可以放在源文件的任何位置，但要确保在调用之前编译器已经知道函数的声明。</p>
<h3 id="（三）-函数调用"><a href="#（三）-函数调用" class="headerlink" title="（三） 函数调用"></a>（三） 函数调用</h3><ul>
<li><p><strong>方式</strong>：通过函数名和实际参数列表来调用函数。实际参数会传递给函数定义中的形式参数。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<pre><code class="c">int result = add(3, 5); // 调用 add 函数，并将返回值赋给 result
</code></pre>
<p>函数调用会暂停当前函数的执行，将控制权转移到被调用函数，执行完被调用函数后，再返回到调用函数继续执行后续代码。</p>
<h3 id="（四）参数传递"><a href="#（四）参数传递" class="headerlink" title="（四）参数传递"></a>（四）参数传递</h3><ul>
<li><strong>值传递</strong>：将实际参数的值复制一份传递给函数的形式参数。在函数内部对形式参数的修改不会影响实际参数。例如：</li>
</ul>
<pre><code class="c">void modifyValue(int num) &#123;
    num = num * 2;
&#125;
int main() &#123;
    int value = 10;
    modifyValue(value);
    printf(&quot;Value after call: %d\n&quot;, value); // 输出 10
    return 0;
&#125;
</code></pre>
<ul>
<li><strong>指针传递</strong>：将实际参数的地址传递给函数的形式参数。通过指针，函数可以修改实际参数的值。例如：</li>
</ul>
<pre><code class="c">void modifyValue(int *num) &#123;
    *num = *num * 2;
&#125;
int main() &#123;
    int value = 10;
    modifyValue(&amp;value);
    printf(&quot;Value after call: %d\n&quot;, value); // 输出 20
    return 0;
&#125;
</code></pre>
<ul>
<li><strong>数组传递</strong>：数组作为函数参数时，实际上传递的是数组首元素的地址，相当于指针传递。函数声明中可以写成 <code>void func(int arr[], int size)</code> 或 <code>void func(int *arr, int size)</code>，其中 <code>size</code> 用于指定数组的大小。例如：</li>
</ul>
<pre><code class="c">void printArray(int arr[], int size) &#123;
    for (int i = 0; i &lt; size; i++) &#123;
        printf(&quot;%d &quot;, arr[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;
int main() &#123;
    int numbers[5] = &#123;1, 2, 3, 4, 5&#125;;
    printArray(numbers, 5);
    return 0;
&#125;
</code></pre>
<h3 id="（五）返回值"><a href="#（五）返回值" class="headerlink" title="（五）返回值"></a>（五）返回值</h3><ul>
<li><strong>类型</strong>：函数通过 <code>return</code> 语句返回一个值，返回值的类型必须与函数定义的返回类型一致。</li>
<li><strong>无返回值</strong>：如果函数不需要返回值，返回类型可以定义为 <code>void</code>。此时，函数中可以没有 <code>return</code> 语句，或者使用 <code>return;</code> 来提前结束函数执行。例如：</li>
</ul>
<pre><code class="c">void printMessage() &#123;
    printf(&quot;Hello, World!\n&quot;);
    // 这里可以没有 return 语句
&#125;
</code></pre>
<h3 id="（六）递归函数"><a href="#（六）递归函数" class="headerlink" title="（六）递归函数"></a>（六）递归函数</h3><ul>
<li><strong>定义</strong>：递归函数是在函数内部调用自身的函数。递归函数需要有一个终止条件，否则会导致无限递归，最终耗尽系统资源。</li>
<li><strong>示例</strong>：计算阶乘的递归函数</li>
</ul>
<pre><code class="c">int factorial(int n) &#123;
    if (n == 0 || n == 1) &#123;
        return 1;
    &#125; else &#123;
        return n * factorial(n - 1);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，<code>factorial</code> 函数在 <code>n</code> 为 0 或 1 时返回 1，否则通过调用自身 <code>factorial(n - 1)</code> 来计算 <code>n</code> 的阶乘。</p>
<h2 id="十、结构体"><a href="#十、结构体" class="headerlink" title="十、结构体"></a>十、结构体</h2><h3 id="（一）结构体定义"><a href="#（一）结构体定义" class="headerlink" title="（一）结构体定义"></a>（一）结构体定义</h3><ul>
<li><strong>基本形式</strong>：使用 <code>struct</code> 关键字定义结构体。例如：</li>
</ul>
<pre><code class="c">struct Student &#123;
    char name[50];
    int age;
    float grade;
&#125;;
</code></pre>
<p>这里定义了一个名为 <code>Student</code> 的结构体，它包含三个成员：一个字符数组 <code>name</code> 用于存储学生姓名，一个整数 <code>age</code> 表示年龄，以及一个浮点数 <code>grade</code> 表示成绩。</p>
<ul>
<li><strong>定义结构体变量</strong>：定义结构体后，可以通过以下方式声明结构体变量：</li>
</ul>
<pre><code class="c">struct Student student1;
</code></pre>
<p>也可以在定义结构体时直接声明变量：</p>
<pre><code class="c">struct Student &#123;
    char name[50];
    int age;
    float grade;
&#125; student2;
</code></pre>
<h3 id="（二）结构体成员访问"><a href="#（二）结构体成员访问" class="headerlink" title="（二）结构体成员访问"></a>（二）结构体成员访问</h3><ul>
<li>通过结构体变量名和成员运算符 <code>.</code> 来访问结构体的成员。例如：</li>
</ul>
<pre><code class="c">struct Student student1;
strcpy(student1.name, &quot;Alice&quot;);
student1.age = 20;
student1.grade = 3.5;
</code></pre>
<ul>
<li>如果是结构体指针，则使用 <code>-&gt;</code> 运算符来访问成员。例如：</li>
</ul>
<pre><code class="c">struct Student *ptr = &amp;student1;
printf(&quot;Name: %s\n&quot;, ptr-&gt;name);
printf(&quot;Age: %d\n&quot;, ptr-&gt;age);
printf(&quot;Grade: %.2f\n&quot;, ptr-&gt;grade);
</code></pre>
<h3 id="（三）结构体初始化"><a href="#（三）结构体初始化" class="headerlink" title="（三）结构体初始化"></a>（三）结构体初始化</h3><ul>
<li><strong>定义时初始化</strong>：在定义结构体变量时，可以对其成员进行初始化。例如：</li>
</ul>
<pre><code class="c">struct Student student3 = &#123;&quot;Bob&quot;, 21, 3.8&#125;;
</code></pre>
<ul>
<li><strong>部分初始化</strong>：可以只初始化部分成员，未初始化的成员会被赋予默认值（对于数值类型通常为 0，对于指针类型为 <code>NULL</code>）。例如：</li>
</ul>
<pre><code class="c">struct Student student4 = &#123;&quot;Charlie&quot;&#125;;
</code></pre>
<p>这里 <code>student4</code> 的 <code>age</code> 会被初始化为 0，<code>grade</code> 也会被初始化为 0.0。</p>
<h3 id="（四）结构体作为函数参数"><a href="#（四）结构体作为函数参数" class="headerlink" title="（四）结构体作为函数参数"></a>（四）结构体作为函数参数</h3><ul>
<li><strong>值传递</strong>：可以将结构体变量作为函数参数传递，这种方式是值传递，即函数内部对结构体参数的修改不会影响到外部的结构体变量。例如：</li>
</ul>
<pre><code class="c">void printStudent(struct Student s) &#123;
    printf(&quot;Name: %s, Age: %d, Grade: %.2f\n&quot;, s.name, s.age, s.grade);
&#125;
</code></pre>
<ul>
<li><strong>指针传递</strong>：为了避免值传递带来的开销（尤其是结构体较大时），可以传递结构体指针。这样函数内部对结构体成员的修改会反映到外部。例如：</li>
</ul>
<pre><code class="c">void updateStudent(struct Student *s) &#123;
    s-&gt;age++;
    s-&gt;grade += 0.5;
&#125;
</code></pre>
<h3 id="（五）结构体嵌套"><a href="#（五）结构体嵌套" class="headerlink" title="（五）结构体嵌套"></a>（五）结构体嵌套</h3><ul>
<li>结构体成员可以是另一个结构体类型。例如：</li>
</ul>
<pre><code class="c">struct Date &#123;
    int day;
    int month;
    int year;
&#125;;

struct Employee &#123;
    char name[50];
    struct Date birthDate;
    float salary;
&#125;;
</code></pre>
<p>访问嵌套结构体成员时，需要使用多个成员运算符。例如：</p>
<pre><code class="c">struct Employee emp1;
strcpy(emp1.name, &quot;David&quot;);
emp1.birthDate.day = 15;
emp1.birthDate.month = 8;
emp1.birthDate.year = 1990;
emp1.salary = 5000.0;
</code></pre>
<h3 id="（六）-结构体数组"><a href="#（六）-结构体数组" class="headerlink" title="（六） 结构体数组"></a>（六） 结构体数组</h3><ul>
<li>可以定义结构体数组，用于存储多个相同结构体类型的数据。例如：</li>
</ul>
<pre><code class="c">struct Student students[3] = &#123;
    &#123;&quot;Eve&quot;, 22, 3.9&#125;,
    &#123;&quot;Frank&quot;, 23, 3.7&#125;,
    &#123;&quot;Grace&quot;, 22, 4.0&#125;
&#125;;
</code></pre>
<p>可以通过数组下标和成员运算符来访问结构体数组中的每个元素的成员。例如：</p>
<pre><code class="c">for (int i = 0; i &lt; 3; i++) &#123;
    printf(&quot;Name: %s, Age: %d, Grade: %.2f\n&quot;, students[i].name, students[i].age, students[i].grade);
&#125;
</code></pre>
<h3 id="（七）结构体与内存对齐"><a href="#（七）结构体与内存对齐" class="headerlink" title="（七）结构体与内存对齐"></a>（七）结构体与内存对齐</h3><ul>
<li>为了提高内存访问效率，结构体成员在内存中存储时会遵循内存对齐规则。编译器会在结构体成员之间插入一些填充字节，使得每个成员的地址都满足特定的对齐要求（通常是成员自身大小的倍数）。例如，一个包含 <code>char</code>（1 字节）、<code>int</code>（4 字节）和 <code>short</code>（2 字节）的结构体，其实际占用的内存空间可能大于三者之和（1 + 4 + 2 &#x3D; 7 字节），可能是 8 字节或 12 字节，具体取决于编译器和目标平台。</li>
</ul>
<h2 id="十一、预处理指令"><a href="#十一、预处理指令" class="headerlink" title="十一、预处理指令"></a>十一、预处理指令</h2><h3 id="（一）宏定义"><a href="#（一）宏定义" class="headerlink" title="（一）宏定义"></a>（一）宏定义</h3><ol>
<li><strong>无参宏</strong>：用 <code>#define</code> 定义，如 <code>#define PI 3.14159</code>，预编译时标识符全替换，注意末尾无分号，与常量有别，常量有类型检查。</li>
<li><strong>带参宏</strong>：格式 <code>#define 宏名(参数列表) 替换文本</code>，如 <code>#define SQUARE(x) ((x) * (x))</code>，参数替换类似函数调用，但无类型检查，留意参数加括号防错误替换。</li>
</ol>
<h3 id="（二）文件包含（-include）"><a href="#（二）文件包含（-include）" class="headerlink" title="（二）文件包含（#include）"></a>（二）文件包含（<code>#include</code>）</h3><ul>
<li><strong>系统头文件</strong>：用 <code>#include &lt;文件名&gt;</code>，编译器从系统目录找，像 <code>#include &lt;stdio.h&gt;</code>，引入标准库功能。</li>
<li><strong>自定义头文件</strong>：<code>#include &quot;文件名&quot;</code>，先在当前目录找，可组织自定义代码。为防重复包含，用 <code>#ifndef</code>、<code>#define</code>、<code>#endif</code> 组合，如：</li>
</ul>
<pre><code class="c">#ifndef _MYHEADER_H_
#define _MYHEADER_H_
// 头文件内容
#endif
</code></pre>
<h3 id="（三）条件编译"><a href="#（三）条件编译" class="headerlink" title="（三）条件编译"></a>（三）条件编译</h3><ul>
<li><strong>基于宏定义</strong>：<code>#ifdef</code> 检查宏是否定义，<code>#ifndef</code> 相反。如：</li>
</ul>
<pre><code class="c">#ifdef DEBUG
    // 调试代码
#endif
</code></pre>
<ul>
<li><strong>基于表达式</strong>：<code>#if</code> 后跟常量表达式，<code>#elif</code> 类似 <code>else if</code>，如：</li>
</ul>
<pre><code class="c">#if defined(_WIN32)
    // Windows 特定代码
#elif defined(__linux__)
    // Linux 特定代码
#endif
</code></pre>
<p>通过条件编译，可依不同条件编译不同代码块。</p>
<h1 id="如果大家还有什么问题，可以加我微信问我"><a href="#如果大家还有什么问题，可以加我微信问我" class="headerlink" title="如果大家还有什么问题，可以加我微信问我"></a>如果大家还有什么问题，可以加我微信问我</h1><p><img src="/../image/weixin.jpg" alt="微信" title="微信"></p>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎指出任何有错误或不够清晰的表达，可以邮件至 2921642540@qq.com 进行反馈。 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024 Puplovoi
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="Toggle full screen shortcut key s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
